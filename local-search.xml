<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cent OS 搭建CS:GO 服务器</title>
    <link href="/2020/04/26/csgo-server/"/>
    <url>/2020/04/26/csgo-server/</url>
    
    <content type="html"><![CDATA[<p>最近在自己的阿里云服务器上搭建CS:GO服务器，由于每次查找比较复杂，所以在此自己整理总结一个可行的方案。</p><p>主要内容是源自<a href="https://www.jianshu.com/p/b2cde3ba7908" target="_blank" rel="noopener">FisherYung</a>的博客总结，在遵循该博客的指引下顺利搭建了私人CS:GO服务器，在此十分感谢FisherYung！</p><h3 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h3><p>首先说一下服务器的选择问题，我这里使用的是阿里云的<strong>轻量应用服务器</strong>，具体配置为：</p><blockquote><p>1核-2GB内存-5Mbps带宽</p></blockquote><p>这里选用<strong>轻量应用服务器</strong>主要是因为它有<code>5Mbps</code>的带宽，能够满足日常使用的大部分需求了。</p><p>下面正式开始CS:GO私人服务器的搭建。</p><h2 id="安装steamcmd、CSGO-Server"><a href="#安装steamcmd、CSGO-Server" class="headerlink" title="安装steamcmd、CSGO Server"></a>安装steamcmd、CSGO Server</h2><h4 id="首先创建一个用户，用来运行CSGO-Server程序"><a href="#首先创建一个用户，用来运行CSGO-Server程序" class="headerlink" title="首先创建一个用户，用来运行CSGO Server程序"></a>首先创建一个用户，用来运行CSGO Server程序</h4><div class="hljs"><pre><code class="hljs shell">useradd -m steam    // 添加名为steam的用户su steam    // 切换到steam用户cd ~    // 切换到steam用户的根目录下</code></pre></div><h4 id="创建steamcmd文件夹，下载steamcmd并解压"><a href="#创建steamcmd文件夹，下载steamcmd并解压" class="headerlink" title="创建steamcmd文件夹，下载steamcmd并解压"></a>创建steamcmd文件夹，下载steamcmd并解压</h4><div class="hljs"><pre><code class="hljs shell">mkdir steamcmd    //创建名为steamcmd的文件夹cd steamcmd/    // 切换到文件夹目录下wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz    //下载steamcmdtar zxvf steamcmd_linux.tar.gz    // 解压steamcmdrm steamcmd_linux.tar.gz    //删除下载的安装包，也可以保留</code></pre></div><h4 id="安装steamcmd运行环境，运行steamcmd并安装CSGO-Server"><a href="#安装steamcmd运行环境，运行steamcmd并安装CSGO-Server" class="headerlink" title="安装steamcmd运行环境，运行steamcmd并安装CSGO Server"></a>安装steamcmd运行环境，运行steamcmd并安装CSGO Server</h4><div class="hljs"><pre><code class="hljs shell">sudo yum install glibc.i686    // 安装steamcmd运行所需的库sudo yum install libstdc++.i686    // 有的主机已经安装其他同样效果的依赖，不用多次安装./steamcmd.sh</code></pre></div><p>在操作正确的情况下会看到以下结果，就证明steamcmd安装完成了。<br><img src="http://image.sincos.vip/blog/20200427/7cB0p1RkG7Hn.png" srcset="/img/loading.gif" alt="steamcmd成功安装"></p><h4 id="下面在steamcmd中安装CS-GO-Server"><a href="#下面在steamcmd中安装CS-GO-Server" class="headerlink" title="下面在steamcmd中安装CS:GO Server"></a>下面在steamcmd中安装CS:GO Server</h4><p>首先以匿名身份登录steamcmd<br><div class="hljs"><pre><code class="hljs shell">login anonymous</code></pre></div></p><p>然后创建CS:GO服务器文件夹，该文件夹在steamcmd文件夹目录下<br><div class="hljs"><pre><code class="hljs shell">force_install_dir ./csgo_server</code></pre></div></p><p>最后安装CSGO服务端，这里需要下载CSGO Server的程序，所以速度视网络状况和带宽而定。<br><div class="hljs"><pre><code class="hljs shell">app_update 740 validate</code></pre></div><br>安装完成后，应该可以看到<strong>Success</strong>的图样。<br><img src="http://image.sincos.vip/blog/20200427/GCaJy9G5N5Mg.png" srcset="/img/loading.gif" alt="安装（更新）成功"></p><p>安装完成后，退出steamcmd<br><div class="hljs"><pre><code class="hljs shell">quit</code></pre></div></p><h2 id="编写CSGO-Server更新脚本"><a href="#编写CSGO-Server更新脚本" class="headerlink" title="编写CSGO Server更新脚本"></a>编写CSGO Server更新脚本</h2><p>该步骤为了更新方便，非必要步骤。</p><h4 id="编写steamcmd-runscript脚本"><a href="#编写steamcmd-runscript脚本" class="headerlink" title="编写steamcmd runscript脚本"></a>编写steamcmd runscript脚本</h4><p>在<code>steamcmd/</code>目录下创建<code>update.txt</code>文件<br><div class="hljs"><pre><code class="hljs shell">vim update.txt</code></pre></div></p><p>在<code>update.txt</code>中输入以下语句<br><div class="hljs"><pre><code class="hljs shell">login anonymousforce_install_dir ./csgo_serverapp_update 740quit</code></pre></div></p><h4 id="编写steamcmd运行脚本"><a href="#编写steamcmd运行脚本" class="headerlink" title="编写steamcmd运行脚本"></a>编写steamcmd运行脚本</h4><p>在<code>steamcmd/</code>目录下创建<code>csgo_server_update.sh</code>脚本文件<br><div class="hljs"><pre><code class="hljs shell">vim csgo_server_update.sh</code></pre></div><br>在<code>csgo_server_update.sh</code>中输入以下语句后保存退出<br><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>./steamcmd.sh +runscript update.txt</code></pre></div></p><h4 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h4><p>在<code>steamcmd/</code>目录下运行脚本<code>csgo_server_update.sh</code><br><div class="hljs"><pre><code class="hljs shell">./csgo_server_update.sh</code></pre></div><br>如果运行成功，则提示<code>Success</code>字样，以后便可采用该脚本来更新CSGO Server脚本</p><p>如果出现权限不足的问题，则需要提升权限，再次运行<br><div class="hljs"><pre><code class="hljs shell">chmod 775 csgo_server_update.sh</code></pre></div></p><h2 id="配置并运行CSGO-Server"><a href="#配置并运行CSGO-Server" class="headerlink" title="配置并运行CSGO Server"></a>配置并运行CSGO Server</h2><h4 id="前往Steam-游戏服务器帐户管理注册登录Steam账号后注册Steam服务器登陆令牌"><a href="#前往Steam-游戏服务器帐户管理注册登录Steam账号后注册Steam服务器登陆令牌" class="headerlink" title="前往Steam 游戏服务器帐户管理注册登录Steam账号后注册Steam服务器登陆令牌"></a>前往<a href="https://steamcommunity.com/dev/managegameservers" target="_blank" rel="noopener">Steam 游戏服务器帐户管理</a>注册登录Steam账号后注册Steam服务器登陆令牌</h4><p>注：如果没有该令牌，则无法联网连接该服务器，只能从本地网络连接。</p><p>在App ID中填入<strong>730</strong>，备忘录中填入<strong>CSGO Server</strong>（此处任意填写）。然后点击创建，获取登陆令牌。</p><p><img src="http://image.sincos.vip/blog/20200427/YI8fkvCeDxnk.png" srcset="/img/loading.gif" alt="注册Steam服务器令牌"></p><h4 id="下载Server-Config"><a href="#下载Server-Config" class="headerlink" title="下载Server Config"></a>下载Server Config</h4><p>切换目录到CSGO的cfg文件夹下，下载server.cfg文件<br><div class="hljs"><pre><code class="hljs shell">cd csgo_server/csgo/cfg/wget http://www.csgodev.com/downloads/server.cfgvim server.cfg</code></pre></div></p><p>进入编辑模式，在<code>server.cfg</code>中添加刚刚注册的登陆令牌，修改部分参数<br><div class="hljs"><pre><code class="hljs shell">// 新增以下参数：// steam account，修改为自己刚刚申请的登陆令牌sv_setsteamaccount "**********************"// 找到并修改以下参数：// 服务器名称，安全方面hostname "Private Server"    // 服务器在社区服务器浏览器上显示的名称，自行修改为喜欢的名字rcon_password "12345678"    // CS:GO远程控制台密码，修改为自己定义的密码sv_password "87654321"    // 服务器连接密码，在连接服务器时输入，不要密码可以留空// 游戏参数方面sv_maxrate "128000"   // 服务器最大带宽使用量，默认值非常小，因此会造成choke值异常，此处建议改为128000sv_minrate "80000"    // 服务器最小带宽使用量，与上面同理，此处建议改为80000sv_accelerate "5.5"   // 人物移动速度，默认值为10，快到恶心，此处建议修改为5.5sv_staminamax 120     // 人物耐力，这里影响跳跃/连跳感受</code></pre></div><br>修改完以上参数之后，服务器便可以启动了，关于<code>server.cfg</code>中的其他参数说明，可以在<code>server.cfg</code>文件的注释中查看，也可以前往<a href="http://csgodev.com/csgodev-server-cfg-for-csgo/" target="_blank" rel="noopener">CSGODev</a>查看。</p><h4 id="开放UDP-27015-端口"><a href="#开放UDP-27015-端口" class="headerlink" title="开放UDP 27015 端口"></a>开放UDP 27015 端口</h4><p>前往阿里云控制面板&gt;安全组设置，开放 <strong>UDP 27015端口</strong>。</p><h4 id="安装screen，启动CSGO-Server"><a href="#安装screen，启动CSGO-Server" class="headerlink" title="安装screen，启动CSGO Server"></a>安装screen，启动CSGO Server</h4><p>安装screen，以便CS:GO服务进程在后台运行<br><div class="hljs"><pre><code class="hljs shell">sudo yum install screen</code></pre></div></p><p>返回csgo_server目录，使用screen创建新的会话<br><div class="hljs"><pre><code class="hljs shell">cd /home/steam/steamcmd/csgo_server/screen -S csgo</code></pre></div><br><strong>注意：进入Screen后，可以使用快捷键：Ctrl + A + D暂离当前会话（不中断会话中进程）</strong><br>下面插播一点Screen的用法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>screen -S [name]</code></td><td style="text-align:center">创建名为name的会话窗口</td></tr><tr><td style="text-align:center"><code>screen -R [name]</code></td><td style="text-align:center">恢复名为name的会话内容</td></tr><tr><td style="text-align:center"><code>screen -ls</code></td><td style="text-align:center">列出当前的所有会话及其状态</td></tr><tr><td style="text-align:center"><code>exit</code></td><td style="text-align:center">退出会话，当会话结束后退出</td></tr><tr><td style="text-align:center"><code>Ctrl + A + D</code></td><td style="text-align:center">暂时退出当前会话（不结束进程）</td></tr></tbody></table></div><p>为了方便，可以在<code>~/steamcmd/csgo_server/</code>目录下创建启动脚本<code>start.sh</code><br><div class="hljs"><pre><code class="hljs shell">cd /home/steam/steamcmd/csgo_servervim start.sh</code></pre></div><br>打开后输入启动脚本和相关参数<br><div class="hljs"><pre><code class="hljs shell">./srcds_run \-debug \-game csgo \-usercon \-console \-tickrate 128 \-port 27015 \-steamcmd_script /home/steam/steamcmd/update.txt \-steam_dir /home/steam/ \+host_workshop_map 465367694 -authkey **********************************</code></pre></div><br>保存退出后，执行<code>./start.sh</code>即可启动服务器</p><p><strong>若系统提示没有srcds_run这个文件，则是你当前的文件夹目录不正确</strong></p><blockquote><p><strong>参数解释：</strong><br>-debug <strong>开启调试模式</strong><br>-game csgo <strong>指明服务器启动游戏：CSGO</strong><br>-usercon <strong>开启user control，即用户可在游戏中使用前面设置的密码进行参数的调整</strong><br>-console <strong>开启游戏控制台</strong><br>-port <strong>游戏服务程序运行端口</strong><br>-steamcmd_script <strong>运行steamcmd的脚本文件地址</strong><br>-steam_dir <strong>Steam的安装地址</strong><br>+host_workshop_map 465367694 <strong>切换地图为来自创意工坊的地图</strong><br>-authkey Steam <strong>Steam网页API的Authkey</strong></p></blockquote><h2 id="使用创意工坊地图"><a href="#使用创意工坊地图" class="headerlink" title="使用创意工坊地图"></a>使用创意工坊地图</h2><h4 id="注册Steam网页API"><a href="#注册Steam网页API" class="headerlink" title="注册Steam网页API"></a>注册Steam网页API</h4><p>前往<a href="https://steamcommunity.com/dev/apikey" target="_blank" rel="noopener">注册 Steam 网页 API 密钥</a>注册API，获得Authkey（注意不要泄露出去）</p><h4 id="获取创意工坊地图ID"><a href="#获取创意工坊地图ID" class="headerlink" title="获取创意工坊地图ID"></a>获取创意工坊地图ID</h4><p>在Steam创意工坊中打开想要的地图页面，可以看到url中的地图ID，修改到上述服务器启动位置即可。</p><h4 id="更换地图"><a href="#更换地图" class="headerlink" title="更换地图"></a>更换地图</h4><p>如果不想通过重启服务器的方法来更换地图，可以在服务器控制台中输入以下命令：<br><div class="hljs"><pre><code class="hljs 1c">changelevel XXXX    <span class="hljs-comment">// XXXX可以是创意工坊地图ID，也可以是官方地图名字</span></code></pre></div></p><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>关于更多创意工坊地图的命令，可以参考<a href="https://developer.valvesoftware.com/wiki/CSGO_Workshop_For_Server_Operators" target="_blank" rel="noopener">官方文档</a></p><h2 id="添加更多Mod和插件"><a href="#添加更多Mod和插件" class="headerlink" title="添加更多Mod和插件"></a>添加更多Mod和插件</h2><p>常用插件为sourcemod和metamod，装了这俩之后才能装满十，kz，僵尸等等插件。</p><h4 id="SourceMod插件"><a href="#SourceMod插件" class="headerlink" title="SourceMod插件"></a>SourceMod插件</h4><p>SourceMod插件需要先到<a href="https://www.sourcemod.net" target="_blank" rel="noopener">SourceMod</a>下载指定系统的插件文件，下载完毕后将解压的<code>addons/</code>和<code>cfg/</code>两个文件夹复制到<code>~/steamcmd/csgo_server/csgo/</code>目录下即可。</p><p>然后到修改<code>~/steamcmd/csgo_server/csgo/addons/sourcemod/configs/admins_simple.ini</code>文件，在文件结尾添加，输入对应的steamID授予管理员权限。<br><a href="https://steamid.io/" target="_blank" rel="noopener">steamID可以在此获取</a><br><div class="hljs"><pre><code class="hljs shell">"（此处输入steamID：STEAM_0:0:********）" "99:z"</code></pre></div><br>完成后可以在游戏中按<code>y</code>或<code>u</code>发言，输入<code>!admin</code>或<code>/admin</code>开启管理员菜单，方便管理游戏内容。</p><h4 id="MetaMod插件"><a href="#MetaMod插件" class="headerlink" title="MetaMod插件"></a>MetaMod插件</h4><p>同SourceMod一样，需要先到<a href="https://www.metamodsource.net" target="_blank" rel="noopener">MetaMod</a>下载指定系统的插件文件，下载完毕后将解压后的<code>addons/</code>和<code>cfg/</code>两个文件夹复制到<code>~/steamcmd/csgo_server/csgo/</code>目录下即可。</p><h4 id="全皮肤插件（有封服务器token风险）"><a href="#全皮肤插件（有封服务器token风险）" class="headerlink" title="全皮肤插件（有封服务器token风险）"></a>全皮肤插件（有封服务器token风险）</h4><p><strong>注意：使用全皮肤插件有封服务器token风险，并且可能牵连绑定同手机号的steam账号，请慎重使用</strong></p><p>全皮肤插件可以自定义武器、刀和手套的皮肤。<br>与之前插件同理，下载对应插件，复制<code>addons/</code>和<code>cfg/</code>两个文件夹到<code>~/steamcmd/csgo_server/csgo/</code>目录下即可。</p><p>首先需要安装<a href="https://ptah.zizt.ru/" target="_blank" rel="noopener">PTaH</a>，然后下载<a href="https://github.com/kgns/weapons/releases" target="_blank" rel="noopener">Weapons</a>和<a href="https://github.com/kgns/gloves/releases" target="_blank" rel="noopener">Gloves</a><br>将上述文件解压后复制到<code>~/steamcmd/csgo_server/csgo/</code>目录下。</p><p>然后将<code>~/steamcmd/csgo_server/csgo/addons/sourcemod/configs/core.cfg</code>中最后的<br><div class="hljs"><pre><code class="hljs shell">"FollowCSGOServerGuidelines"    "yes"</code></pre></div><br>修改为<br><div class="hljs"><pre><code class="hljs shell">"FollowCSGOServerGuidelines"    "no"</code></pre></div><br><img src="http://image.sincos.vip/blog/20200427/zXhE65obmQDo.png" srcset="/img/loading.gif" alt="core.cfg"></p><p>这样就可以在游戏中输入<code>!ws</code>、<code>!knife</code>和<code>!gloves</code>就可以选择自己想要的皮肤啦。</p><h4 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h4><p>其它有用的插件比如warmod等等可以在x社区找到，安装方法一般是放在cfg以及addon文件夹内，使用方法在插件原文里说明的也比较详细，这里给出网址不赘述了。<br><a href="https://www.sourcemod.net" target="_blank" rel="noopener">SourceMod</a><br><a href="https://www.metamodsource.net" target="_blank" rel="noopener">MetaMod</a><br><a href="https://bbs.93x.net" target="_blank" rel="noopener">X社区</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上述的一系列操作，就可以畅快的搭建自己的CSGO Server与好友愉快玩耍啦！</p><p>后续启动服务器只需使用<code>ssh</code>登陆服务器。<br><div class="hljs"><pre><code class="hljs shell">su steamcd /home/steam/steamcmd/csgo_serverscreen -S csgo./start.sh<span class="hljs-meta">#</span><span class="bash"> Ctrl + A + D</span></code></pre></div><br>或恢复之前的会话窗口即可。<br><div class="hljs"><pre><code class="hljs shell">screen -R csgo</code></pre></div></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.jianshu.com/p/b2cde3ba7908" target="_blank" rel="noopener">FisherYung</a>的博客</li><li><a href="http://csgodev.com/csgodev-server-cfg-for-csgo/" target="_blank" rel="noopener">CSGODev</a></li><li><a href="https://steamcommunity.com/dev/managegameservers" target="_blank" rel="noopener">Steam 游戏服务器帐户管理</a></li><li><a href="https://steamcommunity.com/dev/apikey" target="_blank" rel="noopener">注册 Steam 网页 API 密钥</a></li><li><a href="https://developer.valvesoftware.com/wiki/CSGO_Workshop_For_Server_Operators" target="_blank" rel="noopener">创意工坊命令官方文档</a></li><li><a href="https://www.sourcemod.net" target="_blank" rel="noopener">SourceMod</a></li><li><a href="https://www.metamodsource.net" target="_blank" rel="noopener">MetaMod</a></li><li><a href="https://bbs.93x.net" target="_blank" rel="noopener">X社区</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>游戏(Game)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS:GO</tag>
      
      <tag>Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 8 I/O Management</title>
    <link href="/2020/02/03/OS-Chapter-8-I-O-Management/"/>
    <url>/2020/02/03/OS-Chapter-8-I-O-Management/</url>
    
    <content type="html"><![CDATA[<h2 id="Principles-of-I-O-Hardware"><a href="#Principles-of-I-O-Hardware" class="headerlink" title="Principles of I/O Hardware"></a>Principles of I/O Hardware</h2><h3 id="I-O-Device"><a href="#I-O-Device" class="headerlink" title="I/O Device"></a>I/O Device</h3><p>块设备（block device）：把信息存储在固定大小的块中，每个块有自己的地址。按块寻址的。<strong>磁盘</strong>是公认块可寻址设备。<br>字符设备（character device）：以字符为单为发送or接收一个字符流，而不考虑任何块结构。字符设备不可寻址，也没有寻道操作。如：打印机、网络接口、鼠标、老鼠？？？，和大多数与磁盘不同的设备。<br>其他设备：clocks（既不是块可寻址，也不产生or接收字符流）</p><h3 id="Device-Controllers"><a href="#Device-Controllers" class="headerlink" title="Device Controllers"></a>Device Controllers</h3><p>I/O设备由机械部件和电子部件组成<br>机械部件<br>电子部件：称为设备控制器(device controller) or 适配器(adapter)，</p><ul><li>把串行的位流转换为字节块，并进行必要的错误校验。</li><li>能够处理1、2、4…个相同的设备？<h3 id="Memory-Mapped-I-O"><a href="#Memory-Mapped-I-O" class="headerlink" title="Memory-Mapped I/O"></a>Memory-Mapped I/O</h3>设备提供数据缓冲区，供操作系统or程序写入数据。<br>控制寄存器：控制数据传输</li></ul><p>I/O port：每个控制寄存器被分配一个I/O端口号，是一个8位/16位的整数。<br>I/O端口空间：所有的I/O端口形成I/O端口空间，并且受到保护使得普通用户程序不能对其访问（只有OS能访问）</p><p>特殊的I/O指令，例如：</p><blockquote><p>“IN REG，PORT”<br>CPU可以读取控制寄存器PORT的内容并将结果存入到CPU寄存器REG中。<br>“OUT PORT，REG”<br>CPU可以将REG的内容写入控制寄存器中</p></blockquote><p>内存地址空间和I/O地址空间映射</p><blockquote><p>“IN R0，4”读取I/O端口4的内容放入R0   (5-2a)<br>“MOV R0，4”读取内存字4的内容放入R0  (5-2b)</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719931119-93788741-d69f-4f60-8329-e55b8ef27798.png#height=308&amp;width=728" srcset="/img/loading.gif" alt=""> </p><h4 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h4><p>将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，并且不会有内存被分配这一地址。<br>优点：</p><ol><li>I/O设备驱动程序可以用C语言来写，如果不是内存映射IO，就得用汇编。</li><li>不需要特殊的保护机制来组织用户进程执行I/O操作</li><li>可以引用内存的每一条指令也可以引用控制寄存器。否则要看控制寄存器，就需要先读入CPU，再查看值。</li></ol><p>缺点：</p><ol><li>内存高速缓存给设备控制寄存器有问题，循环的时候从高速缓存中取值后不在查询设备，导致不能发现设备状态。</li><li>内存模块和I/O设备必须检查内存引用，看谁作出反应。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719931327-9c4b5ef8-83ad-49a0-9995-2f3bdb86fc8e.png#height=290&amp;width=592" srcset="/img/loading.gif" alt=""></li></ol><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p>当I/O设备完成工作时，就产生一个中断。</p><ol><li>设备完成工作→通知中断控制器</li><li>中断控制器发出中断信号→CPU</li><li>CPU响应中断→中断控制器<br>中断向量：地址线上的数字被用作指向中断向量的表格的索引<h4 id="中断-amp-陷阱"><a href="#中断-amp-陷阱" class="headerlink" title="中断 &amp; 陷阱"></a>中断 &amp; 陷阱</h4>|   | 中断 | 陷阱 |<br>| —- | —- | —- |<br>| 中断原因 | 外部中断，无法预知什么时候发生 | 当前运行的软件软件主动产生的中断，要求陷入内核态 |<br>| 中断处理机制 | 由中断控制器响应 | 系统调用，陷入内核态 |<br>| 行动时间 | 程序运行中，无法预知时间 | 知道发生时间，程序预先设定 |<br>| 发生环境 |   |   |</li></ol><h4 id="精确中断-amp-不精确中断"><a href="#精确中断-amp-不精确中断" class="headerlink" title="精确中断 &amp; 不精确中断"></a>精确中断 &amp; 不精确中断</h4><p>精确中断：将机器留在一个明确状态的中断</p><ol><li>PC（程序计数器）在存在一个已知的地方</li><li>PC所指向的指令之前的所有指令已经完全执行</li><li>PC所指向的指令之后的所有指令都没有执行</li><li>PC所指向的指令的执行状态是已知的</li></ol><p>不精确中断：不满足上面那些要求的中断<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719931502-40024cf2-bf18-4757-bd01-644d787026fa.png#height=210&amp;width=464" srcset="/img/loading.gif" alt=""> </p><h2 id="Principles-of-I-O-Software"><a href="#Principles-of-I-O-Software" class="headerlink" title="Principles of I/O Software"></a>Principles of I/O Software</h2><h3 id="I-O软件的目标"><a href="#I-O软件的目标" class="headerlink" title="I/O软件的目标"></a>I/O软件的目标</h3><p>设备独立性：应该能够编写出程序：可以访问任意I/O设备而无需事先制定设备。（例如，硬盘、CD-ROM、USB无需为每一个设备独立编写程序）<br>统一命名：一个文件或一个设备的名字应该是一个简单的字符串或一个整数， 它不应依赖于设备<br>错误处理：错误应该尽可能地再接近硬件地层面得到处理<br>同步（阻塞）&amp;异步（中断驱动）传输<br>缓冲（buffering）：数据离开一个设备之后通常并不能直接存放到其最终的目的地<br>共享（shareable）设备：磁盘可以共享<br>独占（dedicated）设备：磁带机不能共享</p><h3 id="程序控制I-O（忙等待）"><a href="#程序控制I-O（忙等待）" class="headerlink" title="程序控制I/O（忙等待）"></a>程序控制I/O（忙等待）</h3><p>让CPU做全部工作<br>CPU把任务交给I/O设备，等待完成，等待过程需要 轮询(polling) or 忙等待(busy waiting)</p><h3 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h3><p>CPU将任务交给I/O设备后，继续运行其他进程，当I/O设备完成后发送中断请求，调用中断服务过程，CPU保存现场→响应中断→恢复现场 继续执行之前的进程。</p><h3 id="使用DMA的I-O"><a href="#使用DMA的I-O" class="headerlink" title="使用DMA的I/O"></a>使用DMA的I/O</h3><p>DMA控制器本质是程序控制I/O，但是由DMA控制器处理全部工作，CPU获得自由，可以在I/O期间做其他工作。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719931707-371b7441-17f8-4d04-addc-ed2f645d74b7.png#height=222&amp;width=664" srcset="/img/loading.gif" alt=""> </p><h4 id="DMA-模式"><a href="#DMA-模式" class="headerlink" title="DMA 模式"></a>DMA 模式</h4><p>Burst mode：突发模式，burst只需要提供一个起始地址就行了，以后的地址依次加1，而非burst操作每次都要给出地址，以及需要中间的一些应答、等待状态等等。如果是对地址连续的读取，burst效率高得多，但如果地址是跳跃的，则无法采用burst操作<br>Fly-by mode：被传输的数据既 不通过 DMA 芯片，也不存储在 DMA 芯片中。因此，DMA 只能在 I/O 端口和内存地址间传输数据，而不是在两个I/O端口或者两块内存间。</p><h3 id="使用管道的I-O"><a href="#使用管道的I-O" class="headerlink" title="使用管道的I/O"></a>使用管道的I/O</h3><p>CPU干预最少的I/O操作</p><h3 id="磁盘读写时间决定因素"><a href="#磁盘读写时间决定因素" class="headerlink" title="磁盘读写时间决定因素"></a>磁盘读写时间决定因素</h3><ol><li>寻道时间：将磁盘臂移动到适当的柱面上所需的时间</li><li>旋转延迟：等待适当扇区旋转到磁头下所需的时间</li><li>实际数据传输时间</li></ol><p>对大多数磁盘，寻道时间与另外两个时间相比占主导地位，所以减少寻道时间可以充分改善系统性能<br>许多磁盘驱动程序都维护着一张表，该表按柱面号索引。每一柱面的未完成的请求组成一个链表，链表头存放在表的相应表目中。 </p><h2 id="I-O-Software-Layers"><a href="#I-O-Software-Layers" class="headerlink" title="I/O Software Layers"></a>I/O Software Layers</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719931976-6c692b76-54a6-4ce7-95fd-d8bbe4c44233.png#height=340&amp;width=794" srcset="/img/loading.gif" alt=""> </p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><ol><li>保存没有被中断硬件保存的所有寄存器（包括PSW）。、</li><li>为中断服务过程设置上下文，可能包括设置TLB、MMU和页表。</li><li>为中断服务过程设置堆栈</li><li>应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。</li><li>将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中。</li><li>运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息。</li><li>选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行</li><li>为下一次要运行的进程设置MMU上下文，也许还需要设置某个 TLB。</li><li>装入新进程的寄存器，包括其PSW。</li><li>开始运行新进程</li></ol><h3 id="设备响应程序（就是设备驱动）"><a href="#设备响应程序（就是设备驱动）" class="headerlink" title="设备响应程序（就是设备驱动）"></a>设备响应程序（就是设备驱动）</h3><p>设备相应程序：每个连接到计算机上的I/O设备都需要某些设备特定的代码来对其进行控制。这样的代码称为设备驱动程序。</p><p>每个I/O设备关联一个计算机需要一个特定的设备响应程序<br>每个设备驱动一般只能处理一种设备，最多是一类相似的设备<br>为了响应硬件设备（控制寄存器），设备驱动通常都需要进入内核态</p><h3 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719932155-4836f60b-3cea-4a0c-8b7f-8f92151ebebf.png#height=208&amp;width=528" srcset="/img/loading.gif" alt=""> </p><h4 id="设备驱动程序的统一接口"><a href="#设备驱动程序的统一接口" class="headerlink" title="设备驱动程序的统一接口"></a>设备驱动程序的统一接口</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719932399-911249cf-6089-411c-8db9-d2888fa4889d.png#height=366&amp;width=698" srcset="/img/loading.gif" alt=""> </p><ul><li>没有标准驱动的程序接口：需要大量全新的编程工作，为每个设备编写驱动程序。</li><li>有标准的驱动程序接口：只需要直到驱动程序接口什么亚子，就很轻松容易。<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719932661-e6a0206e-cd19-4525-b823-876d34701d0b.png#height=356&amp;width=672" srcset="/img/loading.gif" alt=""> </li></ul><ol><li>没缓冲：对于每个到来的字符，都必须启动用户进程</li><li>用户缓冲：放入缓冲区直到字符填满。（如果缓冲区被分页调出内存，就把缓冲区锁定在内存中，可能会下降系统性能）</li><li>内核空间缓冲复制到用户空间：一个不够就来俩</li><li>双缓冲：一个满了放另一个，一个复制给用户缓冲。另一个满了这一个复制完了也清空了。</li><li>循环缓冲区：一个指针指向下一个空闲的字，另一个指针指向缓冲区数据第一个字。<h4 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h4>错误在I/O环境中更为常见<br>I/O错误类型</li></ol><ul><li>编程错误：只是将一个错误代码报告返回给调用者</li><li>实际I/O错误：由驱动程序决定做什么，驱动不知道就向上传递</li></ul><h4 id="与设备无关的块大小"><a href="#与设备无关的块大小" class="headerlink" title="与设备无关的块大小"></a>与设备无关的块大小</h4><p>不同磁盘有不同的扇区大小<br>与设备无关快重组一个逻辑块映射提供给更高层，而与物理块无关</p><h3 id="用户空间I-O软件"><a href="#用户空间I-O软件" class="headerlink" title="用户空间I/O软件"></a>用户空间I/O软件</h3><h2 id="Disks"><a href="#Disks" class="headerlink" title="Disks"></a>Disks</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>磁盘被组织成柱面，每个柱面包含若干磁道，磁道与垂直堆叠的磁头个数相同<br>磁道被分成若干扇区<br>重叠寻道：控制器可以同时控制两个或多个驱动器进行寻道<br>逻辑地址：(x, y, z)<br>x个柱面；y个磁头；每个磁道z个扇区<br>$磁盘容量 = 磁头数 × 柱面数 × 每道扇区数 × 每扇区字节数$</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719933152-c9a8e00f-5591-4510-bb5d-2e8a28ba91a0.png#height=988&amp;width=786" srcset="/img/loading.gif" alt=""> </p><h4 id="CD-ROM"><a href="#CD-ROM" class="headerlink" title="CD-ROM"></a>CD-ROM</h4><h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><h4 id="磁盘读写时间决定因素-1"><a href="#磁盘读写时间决定因素-1" class="headerlink" title="磁盘读写时间决定因素"></a>磁盘读写时间决定因素</h4><ol><li><strong>寻道时间</strong>：将磁盘臂移动到适当的柱面上所需的时间</li><li>旋转延迟：等待适当扇区旋转到磁头下所需的时间</li><li><strong>实际数据传输时间</strong></li></ol><p>对大多数磁盘，<strong>寻道时间</strong>与另外两个时间相比占主导地位，所以减少寻道时间可以充分改善系统性能<br>许多磁盘驱动程序都维护着一张表，该表按柱面号索引。每一柱面的未完成的请求组成一个链 表，链表头存放在表的相应表目中。 </p><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h4><p>很难优化寻道时间</p><h4 id="最短寻道优先（SSF）"><a href="#最短寻道优先（SSF）" class="headerlink" title="最短寻道优先（SSF）"></a>最短寻道优先（SSF）</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719933449-4dba055f-8270-4bc5-9019-ae4f916c4b68.png#height=318&amp;width=816" srcset="/img/loading.gif" alt=""><br>移动了61个柱面</p><p>下一次总是处理与磁头距离最近的请求以使寻道时间最小化<br>不断有其他请求到达，那么磁盘更容易停留在中部区域，</p><h4 id="电梯算法（elevator-algorithm）"><a href="#电梯算法（elevator-algorithm）" class="headerlink" title="电梯算法（elevator algorithm）"></a>电梯算法（elevator algorithm）</h4><p>维护一个二进制位：UP 或者 DOWN<br>当一个请求处理完成后，磁盘or电梯 驱动检查位，如果是UP，就移到下一个更高的未完成的请求。如果更高位置没有未完成请求，方向位取反，变为DOWN，同时存在一个地位置请求，就移向该位置。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719933725-4677005f-11bc-410f-a130-7f77e3609172.png#height=360&amp;width=822" srcset="/img/loading.gif" alt=""><br>移动了60个柱面</p><h2 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h2><h2 id="User-Interfaces"><a href="#User-Interfaces" class="headerlink" title="User Interfaces"></a>User Interfaces</h2><h2 id="Power-Management"><a href="#Power-Management" class="headerlink" title="Power Management"></a>Power Management</h2><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><h3 id="脱机技术"><a href="#脱机技术" class="headerlink" title="脱机技术"></a>脱机技术</h3><p>脱离主机的控制进行的I/O操作（使用外围控制机实现的）</p><p>缓解了CPU与慢速I/O设备的速度矛盾<br>即使CPU忙碌，也可以提前将数据输入到磁带（比外围设备快一点的设备）；即使慢速输出设备忙碌，也可以提前将数据输出到磁带（比慢速输出设备快的设备）</p><h3 id="假脱机技术——输入井、输出井"><a href="#假脱机技术——输入井、输出井" class="headerlink" title="假脱机技术——输入井、输出井"></a>假脱机技术——输入井、输出井</h3><ul><li>假脱机技术，SPOOLing技术，使用软件的方式模拟脱机技术。</li><li>输入井：模拟脱机输入时候的磁带，用于收容I/O设备输入的数据</li><li>输出井：模拟脱机输出时候的磁带，收容用户进程输出的数据</li><li>输入进程：模拟脱机输入时候的外围控制机</li><li>输出进程：模拟脱机输出时候的外围控制机</li></ul><p>在磁盘上开辟两个存储区域“<strong>输入井、输出井</strong>”<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719933992-d459bc77-1896-4679-8db6-e6d37de47bf5.png#height=376&amp;width=886" srcset="/img/loading.gif" alt=""> </p><h3 id="假脱机应用"><a href="#假脱机应用" class="headerlink" title="假脱机应用"></a>假脱机应用</h3><p>独占是设备<br>共享设备：允许多个进程“同时”使用的设备<br>SPOOLing能把独占式设备（打印机）改装成共享设备。<br>SPOOLing能把一台物理设备 虚拟成 逻辑上的多台设备</p>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 7 Memory Management</title>
    <link href="/2020/02/03/OS-Chapter-7-Memory-Management/"/>
    <url>/2020/02/03/OS-Chapter-7-Memory-Management/</url>
    
    <content type="html"><![CDATA[<h2 id="No-Memory-Abstraction"><a href="#No-Memory-Abstraction" class="headerlink" title="No Memory Abstraction"></a>No Memory Abstraction</h2><p>没有存储器的抽象，程序直接访问物理内存。<br>帕金森定律：Programs expand to fill the memory available to hold them!<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719263896-759b6070-75e3-460b-b6d4-612533c5dfa5.png#height=658&amp;width=658" srcset="/img/loading.gif" alt=""><br>在不使用内存抽象的情况下运行多道程序<br>将两个程序装载到内存中，但是他们指令地址不一样，因为都引用了绝对的物理地址。（重定位问题）</p><p>保护：（IBM 360）给内存块标记上一个保护键，并且比较执行进程的键和访问的每个内存字的保护键。<br>静态重定位：需要给b程序的指令地址全部+16380</p><p>Basic Memory Management</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间是一个进程可用于寻址内存的一套<strong>地址集合</strong>，每个进程都有自己的地址空间，并且这个地址空间独立于其他的地址空间。</p><h4 id="基址寄存器与界限寄存器（动态重定位）"><a href="#基址寄存器与界限寄存器（动态重定位）" class="headerlink" title="基址寄存器与界限寄存器（动态重定位）"></a>基址寄存器与界限寄存器（动态重定位）</h4><p>把每个进程的地址空间映射到物理内存的不同部分。<br>基址寄存器：程序的<strong>起始物理地址</strong>装载到基址寄存器中<br>界限寄存器：<strong>程序的长度</strong>装载到界限寄存器中<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719264146-842b0593-28ac-4c3d-9ebe-cfcec75fd31f.png#height=430&amp;width=388" srcset="/img/loading.gif" alt=""><br>每次访问内存，都给指令加上基址寄存器的值，然后和界限寄存器相比较，看看是否超出界限寄存器，如果超出，就发生错误了。<br>缺点：每次访问内存都需要进行加法和比较运算。比较可以比较快，但是加法就会慢一点。</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul><li>交换技术：把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。</li><li>虚拟内存：能使程序在只有一部分被调入内存的情况下运行<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719264411-28e07719-fa61-4120-8295-9f3708905125.png#height=450&amp;width=738" srcset="/img/loading.gif" alt=""> <h4 id="使用位图的存储管理"><a href="#使用位图的存储管理" class="headerlink" title="使用位图的存储管理"></a>使用位图的存储管理</h4>内存可能被划分为几个字or几千字节的分配单元<br>内存的大小和分配单元的大小决定了位图的大小<br>主要问题：查找位图中指定长度的连续0串是耗时的操作（目的是为了把一个占k个分配单元的进程调入内存）<h4 id="使用链表的存储管理"><a href="#使用链表的存储管理" class="headerlink" title="使用链表的存储管理"></a>使用链表的存储管理</h4>维护一个记录已分配内存段和空闲内存段的链表，其中链表的一个节点是 包含一个进程or两个进程间的一个空闲区<br>链表中每个节点包含：空闲区（H）or进程（P）的指示标志、起始地址、长度、指向下一个节点的指针<h5 id="为创建进程分配内存的算法"><a href="#为创建进程分配内存的算法" class="headerlink" title="为创建进程分配内存的算法"></a>为创建进程分配内存的算法</h5></li></ul><ol><li>首次适配（first fit）算法：<ol><li>存储管理器沿着段链表搜索，直到找到一个足够大的空闲区</li><li>除非空闲区和要分配的空间大小一样，否则将空闲区分成两部分。一部分进程使用，另一部分是新的空闲区。</li></ol></li><li>下次匹配（next fit）算法：<ol><li>类似于首次匹配，但是每次找到合适空闲区时都记录当前位置，以便在下次寻找空闲区时从上次结束的地方开始搜索。<br><code>// 性能略低于首次匹配算法</code></li></ol></li><li>最佳适配（best fit）算法：<ol><li>搜索整个链表</li><li>找出能够容纳进程的最小的空闲区<br><code>// 比ff和nf算法都浪费内存，因为会出现小的没法用的内存块，都浪费了</code></li></ol></li><li>最差匹配（worst fit）算法：<ol><li>搜索整个链表</li><li>分配最大的可用空闲区<br><code>// 也不好使</code><br><code>// 上面的几个，可以改成为空闲区、进程区各维护一个链表，而且空闲块从小到大排序，就快很多，不用遍历链表</code></li></ol></li><li>快速适配（quick fit）算法：<ol><li>为常用大小的空闲区维护一个单独的链表<br>例如，有一个n项的表，该表的第一项是 指向大小为4KB的空闲区链表表头的指针，第二项是指向大小为8KB的 空闲区链表表头的指针，第三项是指向大小为12KB的空闲区链表表头 的指针，以此类推。<h4 id="伙伴式内存管理"><a href="#伙伴式内存管理" class="headerlink" title="伙伴式内存管理"></a>伙伴式内存管理</h4>所有内存块都是$2^n$的大小，每个块都能被分成两个更小的块<br>没有外碎片，只有内碎片<br>将全部的内存，分为$2^0、2^1、2^2、2^3、…、2^m$的大小。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719264626-96bd8658-8e91-4eb4-9c04-427e672385b8.png#height=232&amp;width=528" srcset="/img/loading.gif" alt=""><br>link、rlink：指向节点的直接前驱和直接后继节点。<br>tag：标记内存块状态，1是占用，0是空闲<br>kval：记录该存储块的容量，2m的容量，记录幂次<br>分配算法：<br>假设用户向系统申请大小为n的存储空间，若 $2^{k-1} &lt; n &lt;= 2^k$，就查看可用空间表中大小为$2^k$的链表中有没有可利用的空间节点：</li></ol></li><li>如果该链表不为NULL，可以直接从头部取出一个节点，给用户使用</li><li>如果大小为$2^k$的链表为NULL，就按需要一次查看比$2^k$大的链表，找到后从链表中删除，截取相应大小的空间（$2^k$）给用户使用，剩余的空间，根据大小插入到相应的链表中。<br>回收算法：<br>用户释放存储块时，需要判断该存储块的伙伴是否为空闲块，</li><li>如果是空闲块，则将其合并，然后合并的新的空闲块还需要同伙伴进行判断整合</li><li>如果不是空闲块，直接将空闲块根据大小插入可利用空间表中即可</li></ol><h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><p>每个程序拥有自己的地址空间，这个空间被分割成多个块，<strong>每一块称作一页或页面</strong>。每一页有连续的地址范围。</p><h3 id="分页-paging"><a href="#分页-paging" class="headerlink" title="分页 paging"></a>分页 paging</h3><p>程序产生的地址称为<strong>虚拟地址</strong>（virtual address），构成的空间就是<strong>虚拟空间</strong>（virtual address space）<br>在虚拟内存情况下，虚拟地址是被送到<strong>内存管理单元</strong>（memory management unit，MMU），MMU把虚拟地址映射为物理内存地址。（MMU是CPU芯片的一部分）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719264933-cc6c9532-b523-4ec1-a9ef-bd4221f10b2c.png#height=668&amp;width=606" srcset="/img/loading.gif" alt=""> </p><p>页面（page）：虚拟地址空间按照固定大小划分成称为页面的若干段元<br>页框（page frame）：物理内存中的对应单元称为页框（page frame）</p><h3 id="页表（page-table）"><a href="#页表（page-table）" class="headerlink" title="页表（page table）"></a>页表（page table）</h3><p>虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表找到页框号，然后把页框号拼接到偏移量的高位，替换掉虚拟页号，形成送往内存的物理地址。<br>页表：页表的目的就是把虚拟页面映射为页框。也表示一个函数，参数是虚拟页号，结果是物理页框号。</p><h4 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h4><ul><li>页框号</li><li>在/不在 位：如果是1，则表示有效，可以使用。如果是0，则表示该表项对应虚拟页面不在内存中，访问该页面回引起一个缺页中断。</li><li>保护位：一个页允许什么类型的访问，0表示读/写，1表示只读。或者三位，读、写、执行。</li><li>修改位（dirty bit）：如果一个页面被修改过（脏的），就必须把它写回磁盘，如果没被修改过（干净的），那么只需要把页面丢弃就可以了。</li><li>访问位：帮助系统发生缺页中断时候选择要被淘汰的页面。</li><li>禁止位：禁止访问Buffer一类的高速缓存，用于映射到设备寄存器而不是常规内存的页面。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719265238-90e5182c-63ac-4527-8a1a-f91fc3ea010f.png#height=320&amp;width=762" srcset="/img/loading.gif" alt=""> <h3 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h3>要解决的问题：</li></ul><ol><li>虚拟地址到物理地址的映射要快</li><li>如果虚拟地址空间很大，页表也会很大</li></ol><h4 id="转换检测缓冲区"><a href="#转换检测缓冲区" class="headerlink" title="转换检测缓冲区"></a>转换检测缓冲区</h4><p>设置一个小型硬件，叫<strong>转换检测缓冲区</strong>（Translation Lookaside Buffer，TLB），通常在MMU中，包含少量表项。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719265539-43413943-736a-4d0d-a1b0-daa25d85ab6e.png#height=438&amp;width=752" srcset="/img/loading.gif" alt=""><br>如果发现有效匹配，并且访问操作<strong>不违反保护位</strong>，则将页框号从TLB中取出，而不必再访问页表。如果虚拟页面号在TLB中，但指令读写不符合保护位，就会产生保护错误。<br>如果虚拟页号不在TLB中，就正常页表查询，接着从TLB中淘汰一个表项，用新的页表项代替它。<br>当表项被清除出TLB时，将修改为复制到内存中的页表项。</p><h4 id="软件TLB管理"><a href="#软件TLB管理" class="headerlink" title="软件TLB管理"></a>软件TLB管理</h4><p>用软件管理TLB，高效，加速。</p><ol><li>软失效：一个页面访问在内存中，不在TLB中。要更新一下TLB，不需要I/O</li><li>硬失效：页面本身不在内存中（当然不在TLB中），要进行一次磁盘I/O，装入页面。<h3 id="针对大内存的页表"><a href="#针对大内存的页表" class="headerlink" title="针对大内存的页表"></a>针对大内存的页表</h3><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719265966-b1a18b94-bfa6-4fa5-9ff7-35e4dd9cc515.png#height=792&amp;width=752" srcset="/img/loading.gif" alt=""><br>32位地址：前10 是页表1，中间10 是页表2，最后12是偏移量<br>避免把全部页表一直保存在内存中<br>索引顶级页表→二级页表<h4 id="倒排页表（64位机）"><a href="#倒排页表（64位机）" class="headerlink" title="倒排页表（64位机）"></a>倒排页表（64位机）</h4>实际内存中每个页框有一个表项，而不是每个虚拟页面有一个表项。<br>缺点：从虚拟地址到物理地址转换必须搜索整个倒排页表来查找某个表项</li></ol><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p><strong>局部性原理：CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都区域聚集在一个较小的连续区域中。</strong></p><ul><li>时间局部性：如果一个信息项正在被访问，那么在<strong>近期</strong>它可能还会被<strong>再次访问</strong></li><li>空间局部性：在<strong>最近的将来</strong>将用到的信息很可能与现在正在使用的信息在空间地址上是<strong>邻近的</strong><h3 id="写时拷贝（Copy-on-Write）"><a href="#写时拷贝（Copy-on-Write）" class="headerlink" title="写时拷贝（Copy on Write）"></a>写时拷贝（Copy on Write）</h3>两个进程同时指向一个页面，当一个进程对页面A进行写操作，导致页面A变化时，创建一个A的副本。</li></ul><p>该技术提供了快速的进程创建，并最小化了必须分配被新创建进程页面的数量。<br>这些共享页面被标记为“写时拷贝”页面，意味着如果其中一个段进程堆共享页面进行了写操作，那么将创建一个共享页面的拷贝。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719266247-46849b1f-a963-4495-bac9-3ab509e33488.png#height=318&amp;width=788" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719266543-9fc77be4-ffa0-41be-9e22-1a1f82ccd75d.png#height=422&amp;width=788" srcset="/img/loading.gif" alt=""> </p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存是一维的<br>分段是二维的：段号+段内地址<br>分段存储的产生：分页一维，表随着编译不断增长，只能被分配到连续的块中。<br>每个段由一个从0到最大的线性地址序列构成<br>各个段的长度可以是0到某个允许的最大值之间的任何一个值<br>不同的段的长度可以不同，并且可以动态改变。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719266838-d0526017-ea54-4cdb-9af1-eaac46f134a9.png#height=462&amp;width=734" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719267173-fe4abda9-5610-4ee0-90e4-74acd7be881d.png#height=648&amp;width=732" srcset="/img/loading.gif" alt=""> </p><h3 id="纯分段实现"><a href="#纯分段实现" class="headerlink" title="纯分段实现"></a>纯分段实现</h3><p>页是定长的，段不是定长的<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719267432-0ed44c02-b88d-42d6-a926-fe56e9c2b33a.png#height=396&amp;width=684" srcset="/img/loading.gif" alt=""><br>这里面的碎片叫外部碎片or棋盘型碎片</p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><div class="table-container"><table><thead><tr><th style="text-align:center">段号</th><th style="text-align:center"><strong>段长</strong></th><th style="text-align:center">基址</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>段表记录了内存中的起始位置，各个段的段表项的长度相同。</p><h3 id="分段分页结合：MULTICS"><a href="#分段分页结合：MULTICS" class="headerlink" title="分段分页结合：MULTICS"></a>分段分页结合：MULTICS</h3><p>分页、分段</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">分页</td><td style="text-align:center">内存利用率高，不会产生外部碎片</td><td style="text-align:center">不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td style="text-align:center">分段</td><td style="text-align:center">很方便按照逻辑模块实现信息共享和保护</td><td style="text-align:center">如果段长过大，为其分配很大连续空间不方便。同时会产生外部碎片。</td></tr></tbody></table></div><p>逻辑地址结构：</p><div class="table-container"><table><thead><tr><th style="text-align:center">段号</th><th style="text-align:center">页号</th><th style="text-align:center">页内偏移量</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>段表</p><div class="table-container"><table><thead><tr><th style="text-align:center">段号</th><th style="text-align:center">页表长度</th><th style="text-align:center">页表存放地址</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>把段分页的操作是由操作系统完成的，对用户不可见。<br>一个进程→一个段表→多个页表<br><strong>3次访问内存</strong></p><ol><li>访问段表</li><li>访问页表</li><li>访问对应物理单元<br>如果有快表（TLB）命中，就一次访存</li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法（Optimal-Replacement-Algorithm）"><a href="#最优页面置换算法（Optimal-Replacement-Algorithm）" class="headerlink" title="最优页面置换算法（Optimal Replacement Algorithm）"></a>最优页面置换算法（Optimal Replacement Algorithm）</h3><p>替换掉<strong>最远会被访问的页面</strong>（最近最不会被访问的页面）</p><p>问题在于这个算法<strong>实现不了</strong>，因为不知道未来哪个页面会被访问。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719267651-74fda957-6770-4c65-9acf-056a49148998.png#height=236&amp;width=812" srcset="/img/loading.gif" alt=""> </p><h3 id="先进先出页面置换算法（FIFO-Replacement-Algorithm）"><a href="#先进先出页面置换算法（FIFO-Replacement-Algorithm）" class="headerlink" title="先进先出页面置换算法（FIFO Replacement Algorithm）"></a>先进先出页面置换算法（FIFO Replacement Algorithm）</h3><p>替换掉<strong>最先读入</strong>内存的页<br>是最简单的页面置换算法<br>表现并不是一直很好</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719267857-c73238aa-e050-4282-b60f-2ce7a9a77505.png#height=226&amp;width=816" srcset="/img/loading.gif" alt=""> </p><h3 id="第二次机会页面置换算法（Second-Chance-Replacement-Algorithm）"><a href="#第二次机会页面置换算法（Second-Chance-Replacement-Algorithm）" class="headerlink" title="第二次机会页面置换算法（Second Chance Replacement Algorithm）"></a>第二次机会页面置换算法（Second Chance Replacement Algorithm）</h3><p>在FIFO基础上做一点点修改。<br>检查最老页面的R位</p><ul><li>如果R位是0，那么这个页面又老又没用，就替换出去。</li><li>如果R位是1，就把R清0，并把这个页面放到链表的尾部（假装变成最近装入的页面），然后继续搜索</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719268083-c14af98f-3f87-46ac-9688-0956128a627c.png#height=336&amp;width=820" srcset="/img/loading.gif" alt=""><br>这里页面上的数字是被装入的时间</p><h3 id="时钟页面置换算法（Simple-Clock-Page-Replacement-Algorithm）"><a href="#时钟页面置换算法（Simple-Clock-Page-Replacement-Algorithm）" class="headerlink" title="时钟页面置换算法（Simple Clock Page Replacement Algorithm）"></a>时钟页面置换算法（Simple Clock Page Replacement Algorithm）</h3><p>第二次机会算法经常要在链表中移动页面，这样既<strong>降低了效率</strong>又没必要，所以把所有页面保存在一个类似钟面的环形链表中，一个表针总是指向最老的页面。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719268300-32c7863e-53d8-4f5a-97db-66a878ba4d01.png#height=370&amp;width=542" srcset="/img/loading.gif" alt=""><br>发生缺页中断时，如果R位是0，就置换新的页面，并且<strong>表针前移一个位置</strong>，如果R位是1，就清除R，并把表针前移一个位置。</p><h3 id="最近最少使用页面置换算法（Least-Recently-Used-Replacement-Algorithm）"><a href="#最近最少使用页面置换算法（Least-Recently-Used-Replacement-Algorithm）" class="headerlink" title="最近最少使用页面置换算法（Least Recently Used Replacement Algorithm）"></a>最近最少使用页面置换算法（Least Recently Used Replacement Algorithm）</h3><p>Least Recently Used（LRU）：最近久未使用<br>在缺页中断发生时，置换未使 用时间最长的页面</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719268483-f9fcf6d5-e8de-4eae-b1e6-38d37b99fec5.png#height=220&amp;width=816" srcset="/img/loading.gif" alt=""> </p><h4 id="LRU算法的实现"><a href="#LRU算法的实现" class="headerlink" title="LRU算法的实现"></a>LRU算法的实现</h4><ol><li>需要维护一个链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。但是链表需要在每次发生内存读取的时候更新一次。</li><li>64位计数器C：每条指令执行完后自动+1，每个页表项必须有一个容纳这个计数器值的域，每次访问内存后，将C的值保存到被访问页面的页表项中，发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的页面。</li><li>n×n位矩阵：当访问页框k时，把k行的位都置1，然后把k列位都置0。在任何时刻，二进制数值最小的行，就是最近最少使用的。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719268761-5267fefc-5df0-449f-b67f-5bec8c901571.png#height=490&amp;width=696" srcset="/img/loading.gif" alt=""> </p><h4 id="LRU栈置换"><a href="#LRU栈置换" class="headerlink" title="LRU栈置换"></a>LRU栈置换</h4><p>每当一个页面被访问，就把他从栈中删除，然后加在栈顶。<br>这样在栈顶的就是最近最常被访问的，而在栈底的就是最近最少访问的页框。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719268971-ec6f1c3c-865d-4850-98cc-a128dad1564a.png#height=348&amp;width=522" srcset="/img/loading.gif" alt=""> </p><h3 id="最不常用页面置换算法（Not-Frequently-Used-Replacement-Algorithm）"><a href="#最不常用页面置换算法（Not-Frequently-Used-Replacement-Algorithm）" class="headerlink" title="最不常用页面置换算法（Not Frequently Used Replacement Algorithm）"></a>最不常用页面置换算法（Not Frequently Used Replacement Algorithm）</h3><h4 id="软件模拟LRU"><a href="#软件模拟LRU" class="headerlink" title="软件模拟LRU"></a>软件模拟LRU</h4><p>NFU（Not Frequently Used，最不常用）算法，每个页面有一个计数器，每次时钟中断时，由操作系统扫描内存中的所有页面，将每个页面的R位（0/1）加到计数器上。发生缺页中断时，置换计数器值最小的页面。<br>但是该算法不会忘记信息，比如在1时刻经常使用，后来不常使用，但仍然不被替换出去。</p><h3 id="老化算法（Aging-Algorithm）"><a href="#老化算法（Aging-Algorithm）" class="headerlink" title="老化算法（Aging Algorithm）"></a>老化算法（Aging Algorithm）</h3><p>修改NFU：</p><ol><li>在R位被加进之前，先将计数器右移一位</li><li>将R位加到计数器最左端的位而不是最右端的位</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719269243-74d19a98-fa24-4ac9-a256-73d268682f88.png#height=510&amp;width=730" srcset="/img/loading.gif" alt=""> </p><h3 id="最少使用置换算法（Least-Frequently-Used）"><a href="#最少使用置换算法（Least-Frequently-Used）" class="headerlink" title="最少使用置换算法（Least Frequently Used）"></a>最少使用置换算法（Least Frequently Used）</h3><p>淘汰最近访问频率最小的元素<br>好像就是老化算法…<br>不对，它是各个位加起来，不是二进制串的最大值<br>意思是：00011111，要比10000000大。</p><h3 id="最近未使用页面置换算法（Not-Recently-Used-Replacement-Algorithm）"><a href="#最近未使用页面置换算法（Not-Recently-Used-Replacement-Algorithm）" class="headerlink" title="最近未使用页面置换算法（Not Recently Used Replacement Algorithm）"></a>最近未使用页面置换算法（Not Recently Used Replacement Algorithm）</h3><p>改进版的Second-Change Algorithm<br>由两个位（Read，Modify）</p><ul><li><ol><li>（0，0）：没有被访问，没有被修改</li></ol></li><li><ol><li>（0，1）：没有被访问，已经被修改</li></ol></li><li><ol><li>（1，0）：已经被访问，没有被修改</li></ol></li><li><ol><li>（1，1）：已经被访问，已经被修改</li></ol></li></ul><p>第1类是第3类R位清零后的结果</p><p>R位被定期清零（比如每次时钟中断）<br>随机选择一个编号最小的非空类中的页面淘汰<br>算法思想：在最近一个时钟中，<strong>淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好</strong></p><h3 id="页面缓冲算法（Page-Buffering-Algorithm）"><a href="#页面缓冲算法（Page-Buffering-Algorithm）" class="headerlink" title="页面缓冲算法（Page-Buffering Algorithm）"></a>页面缓冲算法（Page-Buffering Algorithm）</h3><p>？？？</p><h3 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h3><p>工作集：一个进程当前正在使用的页面的集合就称为工作集。<br>如果整个工作集都在内存中，程序知道运行到下一个执行阶段才会发生中断。<br>抖动（thrashing）：如果每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了抖动/颠簸。<br>工作集模型：设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了<br>预先调页（prepaging）：让进程预先装入其工作集页面<br>工作集：w（k，t）k=最近k次内存访问访问过的页面，t=在任意t时刻。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719269511-59e65ddb-8bee-4b02-8a39-6f8c9e6feef4.png#height=420&amp;width=792" srcset="/img/loading.gif" alt=""></p><p>算法思路：找出一个不在工作集中的页面并淘汰它。<br>需要两条信息：<strong>上次使用该页面的近似时间、R位</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719269793-e137e0e6-6307-4b7b-9681-22e2b4e941a5.png#height=496&amp;width=792" srcset="/img/loading.gif" alt=""><br>扫描页面检查R位</p><ol><li>若R==1，设置上次使用时间为当前实际时间</li><li>若R==0 &amp;&amp; 生存时间 &gt; τ，移出这个页面</li><li>若R==0 &amp;&amp; 生存时间 ≤ τ，记住最小时间（生存时间最长的时间）</li></ol><p>如果扫描完仍然没有空位，就淘汰生存时间最长的页面。</p><h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><p>WSClock：实现简单，性能较好<br>和Clock一样，是一个页框为元素的循环表<br>表项有：上次使用时间、R位、M位<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719270132-292e1f21-af3d-4f4b-a428-86c6efc4f72a.png#height=694&amp;width=648" srcset="/img/loading.gif" alt=""> </p><p>缺页中断 发生，检查指针指向页面</p><ul><li>如果R位是1，则置0，指向下一个元素</li><li>如果R位是0，且页面生存时间＞τ，且页面干净，则不在工作集中，置换该页面。如果页面被修改过（脏的），就不能立即置换，指针继续前进，检查下一个。</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719270365-4b77e693-2b9e-4c4c-a96e-688c9eff3b74.png#height=316&amp;width=648" srcset="/img/loading.gif" alt=""><br>最好的两个是：老化算法、工作集时钟算法</p><h3 id="Stack-Algorithm——栈式算法"><a href="#Stack-Algorithm——栈式算法" class="headerlink" title="Stack Algorithm——栈式算法"></a>Stack Algorithm——栈式算法</h3><h4 id="Belady’s-Anomaly"><a href="#Belady’s-Anomaly" class="headerlink" title="Belady’s Anomaly"></a>Belady’s Anomaly</h4><p>对于某些页面置换算法，页框增加，缺页中断次数反而增加<br>FIFO会出现，内存越大，反而发生缺页中断的次数变多的情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719270557-a913719d-d38f-48cc-b4d8-5adab39944eb.png#height=208&amp;width=738" srcset="/img/loading.gif" alt=""><br>如果内存中<strong>页数更小的集合是内存页数更大的集合的子集</strong>，这个算法被称为stack algorithm。可以证明stack algorithm(如LRU)不会出现belady现象，FIFO会出现。</p><p>Stack Algorithm<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719270703-3947950f-7d14-45a3-946b-44a4baf7e1a7.png#height=172&amp;width=438" srcset="/img/loading.gif" alt=""> </p><h4 id="Distance-Strings"><a href="#Distance-Strings" class="headerlink" title="Distance Strings"></a>Distance Strings</h4><p>距离字符串，描述同一个页面两次访问操作的距离（即上次访问后的几次页的访问再次访问同一页）<br>Depends on：</p><ul><li>Reference String</li><li>Page Replacement Algorithms</li><li>To forecast page fault rate in different memory sizes<h3 id="Predicting-Page-Fault-Rates"><a href="#Predicting-Page-Fault-Rates" class="headerlink" title="Predicting Page Fault Rates"></a>Predicting Page Fault Rates</h3><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719270991-93672e3a-0134-49aa-8063-cf2cf69db2f0.png#height=550&amp;width=796" srcset="/img/loading.gif" alt=""> </li></ul><h2 id="Design-Issues-for-Paging-Systems"><a href="#Design-Issues-for-Paging-Systems" class="headerlink" title="Design Issues for Paging Systems"></a>Design Issues for Paging Systems</h2><h3 id="局部分配策略与全局分配策略"><a href="#局部分配策略与全局分配策略" class="headerlink" title="局部分配策略与全局分配策略"></a>局部分配策略与全局分配策略</h3><ul><li>局部页面置换算法：有效地为每个进程分配固定的内存片段</li><li>全局页面置换算法：全局算法在可运行进程之间动态地分配页框，因此分配给各个进程的页框数是随时间变化的<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719271218-c0c57ca7-72ec-422e-8f3c-d3c82c9999d7.png#height=372&amp;width=612" srcset="/img/loading.gif" alt=""> </li></ul><p>使用PFF缺页中断率算法，指出何时增加or减少分配给一个进程的页面，但是没说应该替换哪个页面，只是说分配集的大小。<br>缺页中断率：计算每秒的缺页中断数。<br>FIFO、LRU，既适应局部置换算法，也可以全局置换算法。</p><h3 id="Thrashing-抖动"><a href="#Thrashing-抖动" class="headerlink" title="Thrashing 抖动"></a>Thrashing 抖动</h3><p>每次发生缺页中断，就说是一次抖动/颠簸<br>交换 进出<br>高频页面活动也是抖动<br>如果进程换页的时间比执行时间占比高，就是进程抖动</p><h4 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h4><ol><li>多进程<br>全局页面置换算法<br>循环从另一个过程中获取页框<br>进程换页的时间比执行时间占比高，就是抖动</li><li><p>操作系统监视CPU使用率，如果CPU利用率过低，就让多进程执行多一些<br>使用全局置换算法，不考虑这些也属于哪个进程<br>现在假设进程进入新的执行阶段，并且需要更多页框</p><ul><li>开始缺页中断，抢夺其他进程需要使用的页框。那些进程页缺页中断，继续抢夺其他进程的页框。</li><li><p>这些缺页中断的进程需要使用分页设备来换入换出页，那分页设备队列执行，准备队列就空了</p><p>当进程等待分页设备执行，CPU利用率就低了，回到开始，再次循环。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719271405-bbf1dfa6-ad78-4889-b3a4-897a7a307650.png#height=282&amp;width=486" srcset="/img/loading.gif" alt=""> </p><h4 id="防止抖动措施"><a href="#防止抖动措施" class="headerlink" title="防止抖动措施"></a>防止抖动措施</h4><p>使用局部置换算法（或优先级置换算法）<br>工作集模型（工作集窗口）<br>$L=S$；</p></li></ul></li></ol><ul><li>L：平均缺页中断频率</li><li>S：平均缺页中断不止次数</li><li>CPU：最佳利用率</li></ul><p>L 大于 S，很少缺页，磁盘能力没有被充分利用。<br>L 小于 S，频繁缺页，超过磁盘的处理能力。<br>挂起一些进程</p><h3 id="Load-Control-负载控制"><a href="#Load-Control-负载控制" class="headerlink" title="Load Control 负载控制"></a>Load Control 负载控制</h3><p>总会发生抖动<br>唯一的解决方案就是：暂时从内存中去掉一些进程</p><h3 id="Page-Size-页面大小"><a href="#Page-Size-页面大小" class="headerlink" title="Page Size 页面大小"></a>Page Size 页面大小</h3><p>页面大小是操作系统可以选择的参数<br>选择小页面<br>好处：</p><ul><li>减少内部碎片</li><li>更好适应多样的数据结构，代码块</li><li>减少内存中没用的程序<br>坏处：</li><li>更大的页表，程序需要更多页面</li></ul><p>进程平均大小s个字节，页面大小p个字节，每个页表需要e个字节。<br>开销=se/p+p/2<br>最优页面大小公式：$P=\sqrt{2se}$</p><h3 id="分离指令空间和数据空间"><a href="#分离指令空间和数据空间" class="headerlink" title="分离指令空间和数据空间"></a>分离指令空间和数据空间</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719271835-cca332b1-6012-4cc2-9eb0-3d0da3098261.png#height=334&amp;width=708" srcset="/img/loading.gif" alt=""> </p><h3 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580719272147-80443b03-cd5f-41ec-96b4-3d18389cf6ae.png#height=606&amp;width=684" srcset="/img/loading.gif" alt=""> </p>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 6 File System</title>
    <link href="/2020/02/03/OS-Chapter-6-File-System/"/>
    <url>/2020/02/03/OS-Chapter-6-File-System/</url>
    
    <content type="html"><![CDATA[<p>Essential Requirements：</p><ul><li>必须可以存放大量信息</li><li>信息可以持久存储，到进程结束</li><li>可以支持文件并发访问</li></ul><p>Long-Term Information Storage</p><ul><li>块状存储<ul><li>磁盘</li><li>磁带</li><li>光盘</li><li>闪盘</li></ul></li><li>块级别操作<ul><li>读第i块</li><li>写第i块</li></ul></li></ul><h2 id="File-Concept"><a href="#File-Concept" class="headerlink" title="File Concept"></a>File Concept</h2><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><p>文件：一组有意义的信息的集合<br>大小<br>文件名<br>逻辑结构（内容）：字节序列、记录序列、树<br>文件类型：二进制文件、ASCII文件。可执行文件、存档文件。<br>文件访问权限（保护信息）、文件<br>文件属性：如创建的时间和日期、文件大小等附加信息。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717852490-333a0997-733a-4f11-8d28-0919bf3bf36f.png#height=570&amp;width=616" srcset="/img/loading.gif" alt=""><br>文件操作：Create、Delete、open、close、read、write、Append、Seek、Get Attributes、Set Attributes、Rename<br>文件物理结构：存放在块中</p><h2 id="Directory-Concept"><a href="#Directory-Concept" class="headerlink" title="Directory Concept"></a>Directory Concept</h2><h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><p>文件夹，包含文件</p><h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717852665-b864193d-00c0-471c-8a88-420ec597a080.png#height=188&amp;width=358" srcset="/img/loading.gif" alt=""> </p><h3 id="层次目录存储"><a href="#层次目录存储" class="headerlink" title="层次目录存储"></a>层次目录存储</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717852839-cdc62a79-1a1d-4449-a639-4c2c11dc7405.png#height=252&amp;width=364" srcset="/img/loading.gif" alt=""><br>文件多的情况下，就需要层次结构（目录树），通过这种方式，可以把文件以自然的方式分组。<br>树形目录结构不便于实现<strong>文件的共享</strong>，所以提出了<strong>无环图目录结构</strong>，可以用不同的文件名指向同一个文件，使得整个目录是一个有向无环图。</p><h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>绝对路径名（absolute path name）<br>相对路径名（relative path name）：与工作目录一同使用，可以不用绝对路径，而使用相对路径。（<strong>使用相对路径检索文件可以减少磁盘I/O操作</strong>）<br>工作目录（working directory）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717853097-d878a303-d147-4f1c-9f15-8b9eade17b4e.png#height=592&amp;width=540" srcset="/img/loading.gif" alt=""> </p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>create、delete、opendir、closedir、readdir、rename<br>link（多个目录中出现同一个文件，增加了该文件i-node的计数器，有时称为硬链接。Hard link、symbolic link）<br>unlink（删除目录项）</p><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><h2 id="File-Share-amp-Protection"><a href="#File-Share-amp-Protection" class="headerlink" title="File Share &amp; Protection"></a>File Share &amp; Protection</h2><h2 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File System Implementation"></a>File System Implementation</h2><h3 id="文件系统的类型"><a href="#文件系统的类型" class="headerlink" title="文件系统的类型"></a>文件系统的类型</h3><ul><li>Traditional：ext2</li><li>Newest：ext3、ReiserFS、IBM JFS、xfs</li><li>Other UNIX：minix、ext、xiafs</li><li>FAT-12、FAT16、FAT-32、VFAT、NTFS</li></ul><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><ul><li><strong>主引导记录（Master Boot Record，MBR）</strong>：用来引导计算机，是<strong>引导块</strong>（boot block）</li><li><strong>分区表（Partitions）</strong></li><li><strong>超级块（Superblock）</strong>包含文件系统所有关键参数，计算机启动时，或文件系统首次使用时，把超级块读入内存。</li><li><strong>i-node</strong>：是一个数据结构数组，<strong>每个文件一个</strong>。i-node说明了文件的<strong>方方面面信息</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717853359-55cb70bc-1dfe-45f6-92d2-4acc35a4ed8b.png#height=410&amp;width=832" srcset="/img/loading.gif" alt=""> <h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4>每个文件作为一连串连续数据块存储在磁盘上。每个文件都从一个<strong>新的块</strong>开始存放。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717853657-466aa111-7598-42bb-9e2a-09f8a0f64939.png#height=438&amp;width=778" srcset="/img/loading.gif" alt=""><br>优点：</li></ul><ol><li>实现简单：记录每个文件只需记住第一块的磁盘地址和文件的块数</li><li>读操作性能好：单个操作就可以从磁盘上读出整个文件，只需要一次，之后就不再需要寻道和旋转延迟。</li></ol><p>缺点：随着时间推移，磁盘会变得零碎<br>适用于CD-ROM这样的文件系统，所有文件大小事先知道，而且后续不会再改变</p><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p><strong>每个块的第一个字</strong>作为指向下一块的指针，块的其他部分存放数据。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717853965-6d69961a-a808-4453-9878-f71c2971df3a.png#height=474&amp;width=582" srcset="/img/loading.gif" alt=""><br>优点：可以充分利用每个磁盘块<br>缺点：</p><ol><li>尽管顺序读文件非常方便，但是随机访问却相当缓慢（因为每次都要从文件的第一个块开始读）</li><li>由于指针占用了一些字节，所以每个磁盘块中存储数据的字节数不是2的整数次幂，降低了系统的运行效率。（因为有些程序以2的整数次幂读写磁盘块，所以要读出一个完整的块，就要从两个磁盘块中获取和拼接信息，就引发了额外的开销）</li></ol><h4 id="在内存中采用表的链表分配"><a href="#在内存中采用表的链表分配" class="headerlink" title="在内存中采用表的链表分配"></a>在内存中采用表的链表分配</h4><p>取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表分配的两个不足。<br>内存中这样一个表格称为文件分配表（File Allocation Table，FAT）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717854191-44b0c3bd-ebc9-42c7-a577-ef2ceb4b01e1.png#height=480&amp;width=356" srcset="/img/loading.gif" alt=""><br>缺点：必须把<strong>整个表</strong>都存放在内存中。 </p><h4 id="i-node"><a href="#i-node" class="headerlink" title="i-node"></a>i-node</h4><p>给每个文件赋予一个i-node（index-node）的数据结构，其中列出了文件属性和文件块的磁盘地址。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717854420-3cd79ac7-925c-43c8-9721-7482a6872d4d.png#height=440&amp;width=550" srcset="/img/loading.gif" alt=""><br>优点：只有在对应文件打开时，i-node才在内存中。如果每个i-node占有n个字节，最多允许k个文件同时打开，那么只需要在内存中提前保留n×k个字节。</p><p>i-node的实现：给i-node偏移量，算第几块<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717854659-35d93274-9bb9-416c-b330-0ccf64913d73.png#height=426&amp;width=674" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717854815-193ec0ab-cd83-4985-b194-e117efe19893.png#height=42&amp;width=838" srcset="/img/loading.gif" alt=""> </p><ul><li>同样，要会根据多层索引、混合索引（上面这个i-node）计算出文件的最大长度</li><li>要能自己分析访问某个数据块所需要的读磁盘次数（每次读入下一级索引块都需要一次读磁盘操作，还要看看<strong>顶级索引块 是否已经调入内存</strong>）</li></ul><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>目录入口：</p><ul><li>File Control Block，FCB 文件控制块</li><li>Fixed-size Variable-size</li></ul><p>目录中提供了查找文件磁盘块所需要的信息：</p><ul><li>整个文件的磁盘地址（连续分配方案）</li><li>第一个块的编号（两种链表分配方案）</li><li>i-node编号</li></ul><p>目录项中长文件名<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717855036-d8234763-fe3a-411b-b2f7-0bfe71397b00.png#height=462&amp;width=708" srcset="/img/loading.gif" alt=""> </p><ul><li>长文件名(a)方法，存在文件属性后面。缺点是有空位 &amp; 在删除后会留下空隙，久而久之造成碎片复杂。</li><li>长文件名(b)方法，文件项存放指向文件名的指针，文件名存储在堆中，文件名不需要再从字的边界开始，堆中不会有空隙，但是<strong>需要有好多指针</strong>。</li></ul><p>加快文件搜索</p><ul><li>散列处理文件名，将文件名存放在散列表中。但是需要维护散列表，管理复杂。<br>将查找结果存入高速缓存，在查找之前，先看看<strong>高速缓存</strong>中有没有。</li></ul><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>共享文件的文件系统就是要给<strong>有向无环图（DAG）</strong>，而不是一棵树。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717855201-4fce6fcc-953b-4cbf-b2e6-b569fd523fd9.png#height=354&amp;width=366" srcset="/img/loading.gif" alt=""> </p><h4 id="硬链接（Hard-link）"><a href="#硬链接（Hard-link）" class="headerlink" title="硬链接（Hard link）"></a>硬链接（Hard link）</h4><p>使用<strong>两个文件名指向同一个内部数据结构</strong>（i-node）来代表一个文件<br>i-node中维护一个<strong>计数器</strong>，用来统计连接到当前文件的连接数目。当数目为0时候才真正删除这个文件。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717855382-19134fc7-824f-4646-9f45-6ff8e4277d76.png#height=324&amp;width=646" srcset="/img/loading.gif" alt=""> </p><h4 id="符号链接（symbolic-linking）"><a href="#符号链接（symbolic-linking）" class="headerlink" title="符号链接（symbolic linking）"></a>符号链接（symbolic linking）</h4><p>是一类特殊的文件，这个文件包含了<strong>另一个文件的路径名</strong>（绝对路径or相对路径）<br>真正的文件所有者才有一个i-node的指针。当文件被删除的时候，符号连接找不到文件；而删除符号连接根本不影响该文件。<br>优点：能够跨越磁盘的界限，甚至可以命名在远程计算机上的文件<br>缺点：但是符号链接需要额外的开销，<strong>性能不如硬连接</strong></p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717855617-c1004993-6ffb-44c2-a923-f5c6fd1938dd.png#height=420&amp;width=750" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717855916-ebe998d7-2189-4a6a-b232-bb37a95980a3.png#height=604&amp;width=750" srcset="/img/loading.gif" alt=""> </p><h2 id="File-System-Management"><a href="#File-System-Management" class="headerlink" title="File System Management"></a>File System Management</h2><h3 id="Disk-Space-Management"><a href="#Disk-Space-Management" class="headerlink" title="Disk Space Management"></a>Disk Space Management</h3><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717856148-f1f764d5-91e8-4c94-b887-bee29ba65abf.png#height=426&amp;width=662" srcset="/img/loading.gif" alt=""><br>根据文件系统中大量的文件大小，选择一个合适的块的大小，一般4KB？</p><h4 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h4><p>管理空闲块的方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717856480-77c7870d-0c0e-4367-9e2a-33db7e0c87ad.png#height=488&amp;width=676" srcset="/img/loading.gif" alt=""> </p><ol><li>磁盘块链表：每个块中包含尽可能多的<strong>空闲磁盘块号</strong></li><li>位图：n个块的磁盘需要n位的位图，空闲块用1表示，反之用0表示。</li><li>成组连接法<h4 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h4><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717856720-956b8127-556c-44bc-adf9-4c07601dc6b9.png#height=468&amp;width=678" srcset="/img/loading.gif" alt=""><br>系统管理员分给每个用户拥有文件和块的最大数量，操作系统确保每个用户不超过分给他们的配额<h3 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h3>物理转储：从磁盘0块开始，将全部的磁盘块按顺序输出到磁带上，直到最后一块复制完毕。</li></ol><ul><li>优点：简单、极为快速</li><li>缺点：既不能能跳过选定目录，也无法增量转储，还不能满足恢复个人文件的请求。</li></ul><p>逻辑转储：从一个或几个指定的目录开始，递归地转储其自给定基准日期（例如，最近一次增量转储或全面系统转储的日期）后有所更改的全部文件和目录。</p><ul><li>全部转储</li><li>增量转储</li></ul><h2 id="File-System-Reliability"><a href="#File-System-Reliability" class="headerlink" title="File System Reliability"></a>File System Reliability</h2><h3 id="文件系统一致性"><a href="#文件系统一致性" class="headerlink" title="文件系统一致性"></a>文件系统一致性</h3><p>块的一致性检查<br>文件的一致性检查<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717856985-be467dc2-a7db-4ab5-aa03-90a28cdac3e0.png#height=456&amp;width=854" srcset="/img/loading.gif" alt=""> </p><h2 id="File-System-Performance"><a href="#File-System-Performance" class="headerlink" title="File System Performance"></a>File System Performance</h2><h3 id="高速缓存（Block-cache）"><a href="#高速缓存（Block-cache）" class="headerlink" title="高速缓存（Block cache）"></a>高速缓存（Block cache）</h3><p>或者缓冲区高速缓存（buffer cache），可以减少磁盘访问次数，提高访问速度。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717857188-3d129a20-51a6-4766-a910-df09c75252ee.png#height=338&amp;width=750" srcset="/img/loading.gif" alt=""><br>同页面置换算法：FIFO算法、第二次机会算法、LRU算法。</p><h3 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h3><p>在需要用到快之前，提前将其写入高速缓存，从而提高命中率（局部性原理）</p><h3 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h3><p>把有可能顺序存取的块放在一起，最好放在同一个柱面上，从而减少磁盘臂的移动次数。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717857451-7c7eb097-bebd-46f2-a654-c14638ee85dd.png#height=504&amp;width=812" srcset="/img/loading.gif" alt=""> </p><ol><li>i-node 放在磁盘的开始块</li><li>把磁盘分为柱面组，每个组有自己的块和i-node（这样快）<h2 id="File-System-Cases"><a href="#File-System-Cases" class="headerlink" title="File System Cases"></a>File System Cases</h2>例子，先不看了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 5 IPC: Deadlock</title>
    <link href="/2020/02/03/OS-Chapter-5-IPC-Deadlock/"/>
    <url>/2020/02/03/OS-Chapter-5-IPC-Deadlock/</url>
    
    <content type="html"><![CDATA[<h2 id="Deadlock-Definition"><a href="#Deadlock-Definition" class="headerlink" title="Deadlock Definition"></a>Deadlock Definition</h2><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待</strong>对方手里的资源，导致各进程<strong>都阻塞</strong>，都无法向前推进得现象，就是“死锁”<br>规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。</p><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进<br>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象<br>死循环：进程执行过程中一直跳不出某个循环的现象<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717602316-ebfceade-2eae-4433-a96c-19fbb6a7a640.png#height=360&amp;width=1128" srcset="/img/loading.gif" alt=""> </p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ul><li>抢占资源，资源不可剥夺</li><li>多个进程的运行顺序非法</li><li>信号量使用不当<br>对不可剥夺资源分配不合理，就会发生死锁。<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3>就是资源导致死锁<br>硬件、软件、信息<br>抢占式、非抢占式<h4 id="非抢占式（Nonpreemptable）资源"><a href="#非抢占式（Nonpreemptable）资源" class="headerlink" title="非抢占式（Nonpreemptable）资源"></a>非抢占式（Nonpreemptable）资源</h4>在不引起相关计算失败的情况下，无法把它从占有的进程抢占过来。<h4 id="抢占式（Preemptable）资源"><a href="#抢占式（Preemptable）资源" class="headerlink" title="抢占式（Preemptable）资源"></a>抢占式（Preemptable）资源</h4>可以从拥有它的进程中抢占而不会产生任何副作用（比如存储器）<h4 id="使用资源的顺序："><a href="#使用资源的顺序：" class="headerlink" title="使用资源的顺序："></a>使用资源的顺序：</h4></li></ul><ol><li>请求资源</li><li>使用资源</li><li>释放资源</li></ol><h3 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h3><ol><li>忽略该问题（鸵鸟算法）</li><li>检测死锁并恢复</li><li>仔细对资源进行分配，动态地避免死锁</li><li>通过破坏引起死锁的四个必要条件之一，防止死锁的产生</li></ol><h2 id="Deadlock-Conditions"><a href="#Deadlock-Conditions" class="headerlink" title="Deadlock Conditions"></a>Deadlock Conditions</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><ul><li><strong>互斥条件</strong>：只有对互斥使用的资源争抢才会导致死锁</li><li><strong>不可抢占条件</strong>：进程所获得的资源在未完成前，不能由其他进程强行夺走</li><li><strong>占有和等待（请求和保持）条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求</li><li><strong>循环等待条件</strong>：有一种进程资源的循环等待链，链中每个进程已经获得的资源同时被下一个进程所请求。循环等待未必死锁，死锁 必 循环等待</li></ul><h2 id="Deadlock-Modeling"><a href="#Deadlock-Modeling" class="headerlink" title="Deadlock Modeling"></a>Deadlock Modeling</h2><p>死锁的模型</p><ul><li>使用有向无环图来描述死锁中进程和资源的关系。其中，进程用圆圈⚪表示，资源用方块■表示。</li></ul><p>请求边：进程节点 -&gt; 资源节点<br>分配边：资源节点 -&gt; 进程节点</p><h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><p>死锁检测和死锁恢复<br>构建一张资源分配图<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717602696-3c1ba38a-834a-4962-bd74-fb48232f17fb.png#height=532&amp;width=932" srcset="/img/loading.gif" alt=""><br>从图中可以看到，已经构成环，所以就出现了死锁。</p><h3 id="死锁检测算法——每种类型一个资源"><a href="#死锁检测算法——每种类型一个资源" class="headerlink" title="死锁检测算法——每种类型一个资源"></a>死锁检测算法——每种类型一个资源</h3><ol><li>对图中每个节点N，将N作为起始点执行下面5个步骤</li><li>将L初始化为空表，并清除所有的有向边标记</li><li>将当前节点添加到L的尾部，并检查该节点是否在L中已经出现过两次。如果是，那么该图包含了一个环（已经列在L中），算法结束</li><li>从给定节点开始，检测是否存在没有标记的从该节点出发的有向边。如果存在的话，执行(5)；如果不存在，执行(6)</li><li>随机选取一条没有标记的从该节点出发的有向边，标记它。然后顺着这条有向边找到新的当前节点，返回(3)</li><li>如果该节点是起始节点，那么表明途中不存在任何环，算法结束。否则意味着走进了死胡同，所以需要移走该节点，返回到前一个节点，即当前节点前面的一个节点，并把它作为新的当前节点，同时转到(3)</li></ol><h3 id="死锁检测算法——每种类型多个资源"><a href="#死锁检测算法——每种类型多个资源" class="headerlink" title="死锁检测算法——每种类型多个资源"></a>死锁检测算法——每种类型多个资源</h3><p>数据结构：E向量（现有资源）、A向量（<strong>可用资源</strong>）、C矩阵（<strong>分配矩阵</strong>）、R矩阵（<strong>请求矩阵</strong>）</p><ol><li>寻找一个没有标记的进程Pi，对于他而言R矩阵的第i行向量≤A</li><li>如果找到这样一个进程，那么将C矩阵的第i行向量加入A中，标记该步骤，并转到第一步</li><li>如果没有这样的进程，那么算法终止<br>算法结束时，所有没有标记过的进程都是死锁进程<h2 id="Deadlock-Recovery"><a href="#Deadlock-Recovery" class="headerlink" title="Deadlock Recovery"></a>Deadlock Recovery</h2><h3 id="利用抢占恢复"><a href="#利用抢占恢复" class="headerlink" title="利用抢占恢复"></a>利用抢占恢复</h3>挂起死锁进程，并抢占它的资源，将这些资源分配给其他的死锁线程。<h3 id="利用回滚恢复"><a href="#利用回滚恢复" class="headerlink" title="利用回滚恢复"></a>利用回滚恢复</h3>让一个或多个死锁进程回退到足以避免死锁的地步。要求系统记录进程历史信息，设置还原点。<h3 id="利用杀死进程恢复"><a href="#利用杀死进程恢复" class="headerlink" title="利用杀死进程恢复"></a>利用杀死进程恢复</h3>强制撤销部分、全部死锁的进程，并剥夺进程资源。实现简单，但是代价可能会很大。</li></ol><p>对谁动手：考虑 <strong>进程优先级、已执行时间、还要多久能完成、进程占用了多少资源、进程是交互式or批处理</strong></p><h2 id="Deadlock-Avoidance"><a href="#Deadlock-Avoidance" class="headerlink" title="Deadlock Avoidance"></a>Deadlock Avoidance</h2><ul><li>安全序列：如果系统按照安全序列分配资源，则每个进程都能顺利完成。（安全序列不唯一）</li><li><strong>安全状态</strong>：如果当前可以得到一个安全序列执行完全部进程，那么该状态就是一个安全状态。</li><li><strong>不安全状态</strong>：如果当前没有一个安全序列可以执行完全部进程，那么该状态就是不安全状态。<br>（不安全状态不一定发生死锁，但是死锁一定是在不安全状态）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717603118-3fe8d46a-645c-403c-b069-185cc8120b0a.png#height=642&amp;width=1006" srcset="/img/loading.gif" alt=""> <h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3></li></ul><ol><li>查找右边矩阵是否有一行，其没有被满足的资源数均≤A。如果不存在，那么系统将可能死锁。</li><li>假若找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A上</li><li>重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；或者所有进程的资源需求都得不到满足，此时就是发生了死锁。</li></ol><p>需要的数据结构：<strong>Max</strong>矩阵（描述进程<strong>最大需求</strong>）、Allocation矩阵（描述进程<strong>已分配资源</strong>）、Need矩阵（描述进程<strong>仍然需要的资源</strong>）、Available向量（描述当前<strong>系统可用资源</strong>）、Request向量（描述<strong>本次申请的各种资源量</strong>）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717603392-dbd84a85-1ffa-4458-af92-61f84a891c24.png#height=210&amp;width=1064" srcset="/img/loading.gif" alt=""> </p><h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>使用<strong>SPOOLing技术</strong>，把独占设备在逻辑上改造成<strong>共享设备</strong>。<br>缺点：不是所有资源都可以改造成共享设备</p><h3 id="破坏非抢占式条件"><a href="#破坏非抢占式条件" class="headerlink" title="破坏非抢占式条件"></a>破坏非抢占式条件</h3><ul><li>方案一：当某个进程请求新资源<strong>得不到满足</strong>，就<strong>立即释放保持的所有资源</strong>，等待以后需要的时候再重新申请。</li><li>方案二：某个进程需要的资源被其他所有进程占有时，可以由操作系统协助，将想要的资源<strong>强制剥夺</strong>。这种方式考虑各进程的优先级</li></ul><p>缺点：</p><ol><li>实现复杂</li><li>释放已获得资源可能会导致前一阶段工作失效，所以只适用于易保存、恢复状态的资源，如CPU</li><li>反复申请和释放回增加系统开销，降低吞吐量。</li><li>若方案一，每次释放自己全部资源，然后需要一个一个重新申请回来，这样就可能会导致进程饥饿。</li></ol><h3 id="破坏占有和等待条件"><a href="#破坏占有和等待条件" class="headerlink" title="破坏占有和等待条件"></a>破坏占有和等待条件</h3><p>用静态分配方法，即在<strong>进程运行之前一次性申请完所有需要的全部资源</strong>，则在资源未满足前，不让它投入运行。<strong>一旦投入运行，资源一直占有，不会请求别的资源。</strong></p><p>缺点：</p><ol><li>有些资源可能仅仅需要很短的时间，那一直保持所有资源，就会造成严重的浪费，资源利用率低。</li><li>可能导致某些进程饥饿</li></ol><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>采用顺序资源分配法，给<strong>系统资源编号</strong>，规定<strong>每个进程按照编号递增的顺序请求资源</strong>，同类资源一次申请完。<br><strong>原理分析</strong>：一个进程只有己占有小编号的资源时，才有资格申请电大编号的资源。按此规则，己持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。 </p><p>缺点：</p><ol><li>不方便增加新设备，因为可能要重更新分配所有编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会造成资源浪费</li><li>必须按规定次序申请资源，编程麻烦</li></ol><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>两阶段加锁：在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。<br>通信死锁<br>活锁：忙等待可能导致<br>饥饿</p>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 4 Process Thread Scheduling</title>
    <link href="/2020/02/03/OS-Chapter-4-Process-Thread-Scheduling/"/>
    <url>/2020/02/03/OS-Chapter-4-Process-Thread-Scheduling/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU调度概念"><a href="#CPU调度概念" class="headerlink" title="CPU调度概念"></a>CPU调度概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717521370-85379e88-bf72-4040-950c-be70bba3611f.png#height=486&amp;width=1162" srcset="/img/loading.gif" alt=""> </p><h3 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h3><ul><li>高级调度（作业调度 Long-term schedule）：外存→内存，面向作业<ul><li>从后备队列选择合适的作业调入内存</li><li>无→创建态→就绪态</li><li>发生频率最低</li></ul></li><li>中级调度（内存调度 Middle-term schedule）：外存→内存，面向进程<ul><li>从挂起队列选择合适进程将其数据调回内存</li><li>挂起态→就绪态、阻塞挂起→阻塞态</li><li>发生频率中等</li></ul></li><li>低级调度（进程调度 Short-term schedule）：内存→CPU<ul><li>从就绪队列选择一个进程为其分配处理机</li><li>就绪态→运行态</li><li>发生频率最高<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717521740-756446dd-e8a6-47fc-8515-cc1186c3e306.png#height=428&amp;width=844" srcset="/img/loading.gif" alt=""><br>计算密集型（compute-bound）<br>I/O密集型（I/O-bound）</li></ul></li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度的时机："><a href="#进程调度的时机：" class="headerlink" title="进程调度的时机："></a>进程调度的时机：</h3><ul><li>当前进程主动放弃CPU<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（等待I/O）</li></ul></li><li>当前进程被动放弃CPU<ul><li>分给进程的时间片用完了</li><li>有更紧急的事需要处理（如I/O中断）</li><li>有更高优先级的进程进入就绪队列<h3 id="什么时候不能进程调度："><a href="#什么时候不能进程调度：" class="headerlink" title="什么时候不能进程调度："></a>什么时候不能进程调度：</h3>在处理中断过程中<br>进程在操作系统<strong>内核程序临界区</strong>中（普通的临界区是可以的，如打印机）<br>原子操作过程中（<strong>原语</strong>）</li></ul></li></ul><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><ul><li>非抢占式：只允许进程主动放弃CPU</li><li>抢占式：可以由操作系统剥夺当前进程CPU控制权<ul><li>当一个进程在CPU执行时，有更重要、更紧迫的进程需要使用CPU，则立即暂停当前进程，将CPU分配给更紧迫的那个进程。<code>// 适用于分时操作系统、实时操作系统</code></li></ul></li></ul><h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><ul><li>狭义进程调度：从就绪队列选中一个要运行的进程。</li><li>进程切换：指一个进程让出CPU，让给另一个进程的过程。<ol><li>对原来运行进程数据保存</li><li>新进程数据恢复（程序计数器、程序状态字、数据寄存器等，存放在PCB）</li></ol></li><li>广义进程调度：选择+进程切换</li></ul><h2 id="CPU调度算法评价指标"><a href="#CPU调度算法评价指标" class="headerlink" title="CPU调度算法评价指标"></a>CPU调度算法评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>$利用率=\frac{忙碌时间}{总时间}$<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717522091-2ae9445b-6f07-47e4-a0d9-5e6f94f175d8.png#height=276&amp;width=842" srcset="/img/loading.gif" alt=""> </p><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>$系统吞吐量=\frac{总共完成了多少作业}{总共花费的时间}$<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580717522366-55b553cd-4479-4a4c-bea1-4fcb2f011f25.png#height=112&amp;width=834" srcset="/img/loading.gif" alt=""> </p><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>作业被提交给系统开始，到作业完成为止的时间间隔。<br>包括四部分：</p><ul><li>作业在外存后备队列等待作业调度时间</li><li>进程在就绪队列等待进程调度的时间</li><li>进程在CPU上执行时间</li><li>进程等待I/O操作完成时间</li></ul><script type="math/tex; mode=display">周转时间=作业完成时间-作业提交时间</script><script type="math/tex; mode=display">平均周转时间=\frac{各作业周转时间之和}{作业数}</script><script type="math/tex; mode=display">带权周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行时间}</script><script type="math/tex; mode=display">平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}</script><h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p>进程/作业处于等待CPU状态时间之和<br>进程：进程建立后等待被服务的时间之和<br>作业：建立进程后的等待时间 + 作业在外存后备队列中等待的时间</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>用户提交请求到首次产生响应所用的时间</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理系统-Batch-System"><a href="#批处理系统-Batch-System" class="headerlink" title="批处理系统 Batch System"></a>批处理系统 Batch System</h3><h4 id="先来先服务-FCFS，First-Come-First-Serve"><a href="#先来先服务-FCFS，First-Come-First-Serve" class="headerlink" title="先来先服务 FCFS，First Come First Serve"></a>先来先服务 FCFS，First Come First Serve</h4><p>进程按照请求CPU顺序使用CPU<br>用于作业调度，考虑哪个作业先到达后备队列；用于进程调度，考虑哪个进程先到达就绪队列<br>非抢占式算法<br>优点：公平、算法实现简单<br>缺点：对长作业有利，对短作业不利</p><h4 id="短作业优先（SJF，Shortest-Job-First）"><a href="#短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="短作业优先（SJF，Shortest Job First）"></a>短作业优先（SJF，Shortest Job First）</h4><p>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间<br>最短的作业时间，优先被得到服务。按照到达的进程/作业，最短运行的先服务。<br>非抢占式<br>抢占式（最短剩余时间优先算法）<br>优点：最短平均等待时间、平均周转时间<br>缺点：不公平，对短作业有利，长作业不利，可能<strong>产生饥饿</strong>现象</p><h4 id="最短剩余时间优先算法（SRTN，Shortest-Remain-Time-Next）"><a href="#最短剩余时间优先算法（SRTN，Shortest-Remain-Time-Next）" class="headerlink" title="最短剩余时间优先算法（SRTN，Shortest Remain Time Next）"></a>最短剩余时间优先算法（SRTN，Shortest Remain Time Next）</h4><p>得到<strong>平均等待时间、平均周转时间</strong>最少<br>就是<strong>抢占式的短作业优先</strong></p><h4 id="高响应比优先（HRRN，Highest-Response-Ratio-Next）"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next）" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next）"></a>高响应比优先（HRRN，Highest Response Ratio Next）</h4><p>$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$<br>每次调度先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br>非抢占式算法<br>优点：综合考虑等待时间和运行时间<br>缺点：没有缺点</p><h3 id="交互式系统-Interactive-System"><a href="#交互式系统-Interactive-System" class="headerlink" title="交互式系统 Interactive System"></a>交互式系统 Interactive System</h3><h4 id="时间片轮转（Round-Robin）用于分时操作系统"><a href="#时间片轮转（Round-Robin）用于分时操作系统" class="headerlink" title="时间片轮转（Round-Robin）用于分时操作系统"></a>时间片轮转（Round-Robin）用于分时操作系统</h4><p>算法思想：<strong>公平</strong>、轮流为各个进程服务<br>算法规则：按照各进程到达就绪队列顺序，轮流让进程执行一个时间片（如100ms），若进程未在时间片内执行完，就剥夺CPU，将进程<strong>重新放入就绪队列队尾</strong><br>用于进程调度<br>抢占式算法，由时钟装置发出时钟中断来通知CPU<br>如果时间片太大，就会增大进程响应时间，退化为先来先服务调度算法<br>如果时间片太小，进程切换过于频繁，就会<strong>花费大量时间处理切换</strong>，导致实际执行时间比例减少。</p><p>优点：公平，响应快，适用于分时操作系统<br>缺点：高频率进程切换，有一定开销，不区分任务紧急程度</p><h4 id="优先级调度算法（Priority-Scheduling）"><a href="#优先级调度算法（Priority-Scheduling）" class="headerlink" title="优先级调度算法（Priority Scheduling）"></a>优先级调度算法（Priority Scheduling）</h4><p>思想：场景需要根据任务紧急程度决定处理顺序<br>规则：每个作业/进程有各自的优先级，<strong>调度时选择优先级最高的</strong>。优先级一样，处理<strong>先到达的</strong><br>既能作业调度，也能进程调度<br>抢占式、非抢占式都有<br>静态优先级：创建进程确定，之后一直不变<br>动态优先级：创建进程有一个初始值，之后动态调整<br>系统进程优先级高于用户进程<br>前台进程优先级高于后台进程<br>操作系统偏好I/O型进程（对整体利用率、吞吐量有提升）<br>动态调整：追求公平、提升资源利用率、频繁IO操作提升优先级<br>优点：优先级区分紧急程度、重要程度，适用于实时操作系统<br>缺点：如果源源不断高优先级，就会<strong>导致饥饿</strong></p><h4 id="多级反馈队列调度算法（Multi-level-Feedback-queue-scheduling）"><a href="#多级反馈队列调度算法（Multi-level-Feedback-queue-scheduling）" class="headerlink" title="多级反馈队列调度算法（Multi-level Feedback queue scheduling）"></a>多级反馈队列调度算法（Multi-level Feedback queue scheduling）</h4><p>思想：前两种的折中<br>规则：</p><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达进入一级队列，运行时间片用完（时间片没用完被抢占，就返回当前级队列）程序还未结束，放入下一级队列（当处于最后一级队列的时候，重新回到最后一级队列）</li><li>只有第k级队列为空，才会为k+1级队头分配时间片</li></ol><p>抢占式算法<br>优点：公平，每个进程都能得到快速响应，短进程经历较少时间就能完成，不必实现估计进程的运行时间，可以灵活调整对各类进程的偏好程度（I/O密集型进程偏好，可以放入当前优先级队列）<br>可能<strong>会导致饥饿</strong></p><h4 id="彩票调度（Lottery-Scheduling）"><a href="#彩票调度（Lottery-Scheduling）" class="headerlink" title="彩票调度（Lottery Scheduling）"></a>彩票调度（Lottery Scheduling）</h4><p>按比例分配给进程彩票，然后抽奖，抽中彩票的就给分配一个时间片。</p><h4 id="More："><a href="#More：" class="headerlink" title="More："></a>More：</h4><p>Guarantee Scheduling<br>Fair-Share Scheduling</p><h3 id="RealTime-System-实时系统"><a href="#RealTime-System-实时系统" class="headerlink" title="RealTime System 实时系统"></a>RealTime System 实时系统</h3><p>实时系统：时间起主导的系统，要求计算机必须在一个确定的时间范围内作出反应<br>Minimizing Latency<br>Priority-Based Scheduling<br>Rate-Monotonic Scheduling<br>Earliest-Deadline-First Scheduling</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>二级调度</p><ul><li>内核级线程：系统范围竞争，需要完整的机器指令</li><li>用户级线程：用户范围竞争，切换需要少量机器指令</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 3 Inter-Process Communication</title>
    <link href="/2020/02/03/OS-Chapter-3-Inter-Process-Communication/"/>
    <url>/2020/02/03/OS-Chapter-3-Inter-Process-Communication/</url>
    
    <content type="html"><![CDATA[<h2 id="Race-Condition-竞争条件-竞态"><a href="#Race-Condition-竞争条件-竞态" class="headerlink" title="Race Condition 竞争条件/竞态"></a>Race Condition 竞争条件/竞态</h2><h3 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h3><p>定义：</p><ul><li>两个或多个进程读写某些共享数据，而最后的结果<strong>取决于进程运行的精确时序</strong>，称为竞争条件（race condition）</li><li>two or more processes are reading or writing some shared data and the final result depends on who runs precisely<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3>需要互斥（mutual exclusion）<br>临界区：对<strong>共享内存</strong>进行访问的<strong>程序片段</strong>称为<strong>临界区域</strong>（critical region/critical section）<br>临界资源（Critical Resource）：文件，内存、信号量</li></ul><h3 id="避免竞态的条件"><a href="#避免竞态的条件" class="headerlink" title="避免竞态的条件"></a>避免竞态的条件</h3><ol><li>任何两个进程不能同时处于其临界区</li><li>不应对CPU的速度和数量做任何假设</li><li>临界区外运行的进程不得阻塞其他进程</li><li>不得使进程无限期等待进入临界区<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715436636-909d68a2-b75a-4e20-aa49-84184f87fe05.png#height=402&amp;width=788" srcset="/img/loading.gif" alt=""> </li></ol><h2 id="Mutual-Exclusion-进程互斥"><a href="#Mutual-Exclusion-进程互斥" class="headerlink" title="Mutual Exclusion 进程互斥"></a>Mutual Exclusion 进程互斥</h2><p>当进程在临界区中更新共享内存时，其他进程将不会进入临界区</p><h3 id="屏蔽中断（硬件-物理解决方式）"><a href="#屏蔽中断（硬件-物理解决方式）" class="headerlink" title="屏蔽中断（硬件/物理解决方式）"></a>屏蔽中断（硬件/物理解决方式）</h3><p>每个进程刚进入临界区后就立即屏蔽所有中断，并在离开之前打开中断。<br>CPU只有发生时钟中断或者其他中断才会切换进程，这样一来就不会进行进程切换了。<br>所以，进程屏蔽中断之后，他就可以检查和修改共享内存，而不必担心其他进程介入<br><strong>缺点：</strong>把屏蔽中断的权利交给用户程序是不明智的，因为一旦不再打开中断，就会造成严重的后果。<br><strong>屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</strong></p><h3 id="锁变量（软件解决方式）"><a href="#锁变量（软件解决方式）" class="headerlink" title="锁变量（软件解决方式）"></a>锁变量（软件解决方式）</h3><p>设定一个信号量，锁定变量，初始位0，当程序进入临界区，如果0就可以进入，然后把值设置为1。如果是1，就等待直到值变为0。<br>0表示临界区没有进程，1表示已经有某个进程进入临界区<br><strong>缺点：</strong>也会出现假脱机类似的问题，即A读出0，并在将其设定为1之前，程序B读出信号量也是0，就出现问题了。</p><h3 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715436932-d3b7794f-e681-4fb0-bd86-52f3f44dfd36.png#height=356&amp;width=866" srcset="/img/loading.gif" alt=""><br>设定整型变量turn，初始值0，a执行进入临界区后turn设定为1，b执行进入临界区后turn设定为0，在一个等待循环中不断测试turn，直到某个值出现，称为<strong>忙等待（busy waiting）</strong>，浪费CPU时间，通常避免。<br>仅在确定等待时间非常短的情况下才使用忙等待，<strong>忙等待的锁</strong>称为<strong>自旋锁</strong>（spin lock）<br>严格要求两个进程<strong>轮流进入</strong>临界区，违反了条件3（A进入后，不管B有没有进入，都得等B进入一次后才能再次进入）。</p><h3 id="Peterson-Solution"><a href="#Peterson-Solution" class="headerlink" title="Peterson Solution"></a>Peterson Solution</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715437426-8212d173-6b4d-41d1-a0b4-d354c7882990.png#height=624&amp;width=900" srcset="/img/loading.gif" alt=""><br>各进程用其进程号（0/1）作为参数调用enter_region，调用后将turn这是为进程号，然后直到等另一个进程（other）的interested[other]变为FALSE之后，才进入进程。</p><h3 id="TSL指令（硬件方案）"><a href="#TSL指令（硬件方案）" class="headerlink" title="TSL指令（硬件方案）"></a>TSL指令（硬件方案）</h3><p><code>TSL RX，LOCK</code><br>测试并加锁（Test and Set Lock），将内存字lock读入寄存器RX，然后后在该地址存非零值，保证读字和写字操作不可分割。<br>（与屏蔽中断不同，屏蔽中断并<strong>不能解决多核心问题</strong>，因为对于CPU1屏蔽，CPU2没有任何影响，让CPU2远离内存的唯一方法就是<strong>锁住总线</strong>，就需要硬件）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715437748-4750e373-581f-43c5-8df9-6547bbe07813.png#height=366&amp;width=896" srcset="/img/loading.gif" alt=""><br>还有一个XCHG指令，原子性的交换了讲个位置的内容，如一个寄存器与一个存储器字<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715438011-0dfd9eae-428e-4262-82c3-6cf160557998.png#height=398&amp;width=898" srcset="/img/loading.gif" alt=""><br>会出现<strong>优先级反转问题</strong>（priority inversion problem），高优先级的程序被低优先级的程序抢占。</p><h3 id="生产者-消费者问题（Producer-Consumer-Problem）-互斥操作要放在同步操作之后"><a href="#生产者-消费者问题（Producer-Consumer-Problem）-互斥操作要放在同步操作之后" class="headerlink" title="生产者-消费者问题（Producer-Consumer Problem）//互斥操作要放在同步操作之后"></a>生产者-消费者问题（Producer-Consumer Problem）//互斥操作要放在同步操作之后</h3><p>有界缓冲区问题（bounded-buffer）<br>两进程共享公共固定缓冲区，一个生产者，一个消费者。<br>添加唤醒等待位，解决wakeup信号丢失的问题，如果一个唤醒等待为</p><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>down：对信号量操作，检查是否大于0，如果大于0，则减一，如果为0，则进程睡眠。<br>up：对信号量增1，如果处于睡眠，无法down，则系统选择一个程序允许弯沉down。如果up后仍然是0，但其仍处于睡眠状态，则睡眠少一个。</p><p>二元信号量（binary semaphore）：供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区，称作二元信号量</p><h3 id="互斥量-mutex"><a href="#互斥量-mutex" class="headerlink" title="互斥量 mutex"></a>互斥量 mutex</h3><p>信号量的简化版，处于两态之一的变量：解锁、加锁。0表示解锁，其他所有值表示加锁。<br>线程/进程访问临界区时，调用mutex_lock，如果临界区可用，则调用成功，线程进入临界区。如果临界区不可用，则等待，直到临界区中的线程调用mutex_unlock，如果有多个等待，则随机选择一个，允许获得锁。<br>enter_region进入临界区失败会忙等待，而mutex_lock失败会调用thread_yield将CPU放弃给另一个线程。当该线程再次运行时候，则再进行一次锁测试。<br>上锁调用mutex_trylock，可以选择成功操作，或者失败了采取什么操作。</p><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><p>互斥量：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715438240-088765ee-eb40-4c99-b0a6-c0ab1964a3ae.png#height=368&amp;width=764" srcset="/img/loading.gif" alt=""><br>条件变量：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715438514-2541e8db-e690-4a08-9055-e665d7d7b993.png#height=404&amp;width=768" srcset="/img/loading.gif" alt=""> </p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>组合：</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据就设定初始值的语句</li><li>有一个名字</li></ol><p>管程是一个由<strong>过程（函数）、变量（共享数据+初始值）及数据结构（共享数据结构）等</strong>组成的一个集合。</p><p>基本特征：</p><ol><li>局部于管程的数据只能被<strong>局部于管程的过程</strong>访问</li><li>一个进程只有通过调用管程内的过程，才能<strong>进入管程访问共享数据</strong></li><li>每次<strong>仅允许一个进程在管程内执行某个内部过程</strong></li></ol><p>任意时刻，管程中只能有一个活跃的进程（其他的阻塞）<br>外部的进程/线程只能通过管程提供的特定的“入口”才能访问共享数据<br>每次仅允许一个进程在管程内执行某个内部过程</p><p>由<strong>编译器</strong>实现各个进程互斥地进入管程中的过程<br>设置条件变量用来实现同步（排队）问题，等待/唤醒操作</p><h3 id="消息传递-message-passing"><a href="#消息传递-message-passing" class="headerlink" title="消息传递 message passing"></a>消息传递 message passing</h3><h3 id="屏障-Barrier"><a href="#屏障-Barrier" class="headerlink" title="屏障 Barrier"></a>屏障 Barrier</h3><p>用于<strong>进程组</strong><br>除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715438805-1cbbaec0-2d4d-47d4-9e39-5d9e10167e06.png#height=516&amp;width=930" srcset="/img/loading.gif" alt=""> </p><h2 id="Synchronization-同步"><a href="#Synchronization-同步" class="headerlink" title="Synchronization 同步"></a>Synchronization 同步</h2><h2 id="Communication-通讯"><a href="#Communication-通讯" class="headerlink" title="Communication 通讯"></a>Communication 通讯</h2><h2 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h2><h2 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h2><p>多类，生产者消费者仅仅获取其需要的<br>对于缓冲区大于1的情况，就要设置互斥信号量。而如果缓冲区为1，则不需要设置互斥信号量。<br>抽象化为事件，事件A→事件B，这样进行分析。</p><h2 id="抽烟者问题"><a href="#抽烟者问题" class="headerlink" title="抽烟者问题"></a>抽烟者问题</h2><p>三个抽烟者进程，一个供应者进程。</p><h2 id="Reader-Writer-Problem"><a href="#Reader-Writer-Problem" class="headerlink" title="Reader-Writer Problem"></a>Reader-Writer Problem</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715439182-0726d910-5d51-44ee-a858-fdc5877624f9.png#height=708&amp;width=1022" srcset="/img/loading.gif" alt=""> </p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715439614-b2358be1-3ffa-4c59-8399-772776e73588.png#height=814&amp;width=1080" srcset="/img/loading.gif" alt=""> </p><h2 id="The-Dining-Philosophers-Problem-哲学家吃饭问题"><a href="#The-Dining-Philosophers-Problem-哲学家吃饭问题" class="headerlink" title="The Dining Philosophers Problem 哲学家吃饭问题"></a>The Dining Philosophers Problem 哲学家吃饭问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715440034-0657dcff-c63d-4574-9f95-cf7b192ddf81.png#height=786&amp;width=1084" srcset="/img/loading.gif" alt=""><br>要访问两个（或以上）<strong>临界资源</strong><br>需要解决死锁问题。</p><ol><li>限制同时吃饭的人数</li><li>规定奇数号拿右边筷子，偶数拿左边筷子</li><li>对拿筷子操作设定互斥量，尽管拿个不是同一个筷子。</li></ol><h2 id="The-Sleeping-Barber-Problem-理发师问题"><a href="#The-Sleeping-Barber-Problem-理发师问题" class="headerlink" title="The Sleeping Barber Problem 理发师问题"></a>The Sleeping Barber Problem 理发师问题</h2><p>一位理发师、一把理发椅、n把供等候理发的顾客坐的椅子<br>如果没有顾客，理发师睡觉<br>第一个顾客，要叫醒理发师、后面的顾客，如果有椅子，则坐下，如果没有，则离开<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715440326-fcbe9a78-2b15-4f64-8931-69147154ab62.png#height=510&amp;width=760" srcset="/img/loading.gif" alt=""> </p><h2 id="Summary-：Inter-Process-Data-Communication"><a href="#Summary-：Inter-Process-Data-Communication" class="headerlink" title="Summary ：Inter-Process Data Communication"></a>Summary ：Inter-Process Data Communication</h2><h3 id="Shared-Memory-System"><a href="#Shared-Memory-System" class="headerlink" title="Shared-Memory System"></a>Shared-Memory System</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715440655-e47e0c4c-4d54-4bc2-9bf6-f668929ec2b2.png#height=378&amp;width=614" srcset="/img/loading.gif" alt=""> </p><h3 id="Message-Passing-System"><a href="#Message-Passing-System" class="headerlink" title="Message Passing System"></a>Message Passing System</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715440965-8c21426b-6762-4d56-801d-389b84179483.png#height=528&amp;width=802" srcset="/img/loading.gif" alt=""> </p><h3 id="Pipeline-System"><a href="#Pipeline-System" class="headerlink" title="Pipeline System"></a>Pipeline System</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715441294-09f3ad20-0dcd-4236-a4c7-f76f0ff85eb0.png#height=504&amp;width=600" srcset="/img/loading.gif" alt=""> </p><h3 id="Remote-Procedure-Call"><a href="#Remote-Procedure-Call" class="headerlink" title="Remote Procedure Call"></a>Remote Procedure Call</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580715441513-0660bdd6-f37d-4efd-9a96-a2c3687eefb8.png#height=318&amp;width=818" srcset="/img/loading.gif" alt=""> </p>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 2 Process &amp; Thread Concepts</title>
    <link href="/2020/02/03/OS-Chapter-2-Process-Thread-Concepts/"/>
    <url>/2020/02/03/OS-Chapter-2-Process-Thread-Concepts/</url>
    
    <content type="html"><![CDATA[<h2 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h2><h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><ul><li>就是一个指令序列</li><li>程序在内存中：存放程序段、数据段</li><li>Input、Compute、Print</li><li>执行方式:<ul><li>顺序执行<ul><li>内存、CPU、系统资源都属于单个程序</li></ul></li><li>并发执行<ul><li>PCB 进程控制块，放在内存中。用来描述进程的各种信息</li><li>内存中存放程序段，数据段</li></ul></li></ul></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程是资源分配的最小单位</strong><br><strong>程序段、数据段、PCB</strong>三部分组成了进程实体。<br>程序段存放程序代码，数据段存放运行时使用、产生的运算数据，如全局变量、局部变量、宏定义常量，都在数据段。<br>进程是一个动态过程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713115778-d2e06375-de3a-4a34-b510-e31539e4088e.png#height=356&amp;width=228" srcset="/img/loading.gif" alt=""> </p><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul><li>PCB <ul><li>进程描述信息<ul><li>PID 进程标识符：进程被创建时分配的唯一的、不重复的ID，用于区分不同进程</li><li>UID 用户标识符</li></ul></li><li>进程管理控制信息<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713116140-1a3f65f2-235a-4d51-8f59-71fb39f28042.png#height=558&amp;width=1038" srcset="/img/loading.gif" alt=""> </li></ul></li></ul><h3 id="进程的组织（多个进程要以什么方式组织起来）"><a href="#进程的组织（多个进程要以什么方式组织起来）" class="headerlink" title="进程的组织（多个进程要以什么方式组织起来）"></a>进程的组织（多个进程要以什么方式组织起来）</h3><ol><li><p>链接方式</p><ul><li>按照进程状态将PCB分为多个队列</li><li><p>操作系统持有指向各个队列的指针</p></li><li><p>执行指针：指向当前处于运行态的进程。（单CPU中，同一时刻只会有一个进程处于运行状态）</p></li><li>就绪队列指针：指向当前处于就绪状态的进程。（优先级高的放在前面）</li><li>阻塞队列指针：指向当前处于阻塞状态的进程，很多操作系统还会根在·据阻塞原因不同，再分为多个阻塞队列。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713116521-8658db41-f4a6-4b72-b599-48d9c9741479.png#height=482&amp;width=902" srcset="/img/loading.gif" alt=""> </li></ul></li><li><p>索引方式</p><ul><li>按照进程状态建立几张索引表</li><li>操作系统持有指向各个索引表的指针<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713116863-42edf999-26f2-4d43-94b2-4dc24f11e418.png#height=560&amp;width=904" srcset="/img/loading.gif" alt=""> </li></ul></li></ol><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><p>进程相比程序，有特征：</p><ul><li><strong>动态性</strong>（基本特征）：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li><strong>并发性</strong>：内存中有多个进程实体，各进程可并发执行</li><li><strong>独立性</strong>：进程是能独立运行、独立获得资源、独立接受调度的基本单位。（是资源分配、接受调度（有了线程以后就不是了）的基本单位）</li><li><strong>异步性</strong>：各进程按各自独立、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题。（并发程序执行结果的不确定。）</li><li><strong>结构性</strong>：每个进程配置一个PCB。从结构上看，进程由程序段、数据段、PCB组成</li></ul><h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li>运行态（Running）：占有CPU，在CPU上运行。（单核就只能有一个，双核可以同时有两个）</li><li>就绪态（Ready）：已经具备运行条件，但没有空闲CPU，就暂时不能运行。（除了CPU，什么资源都已经有了）</li><li>阻塞态（Waiting/Blocking）：因等待某事件而暂时不能运行。</li><li>创建态（New）：进程正被创建，操作系统分配资源、初始化PCB</li><li>终止态（Terminated）：进程从系统中撤销，操作系统回收资源、撤销PCB</li></ul><h3 id="进程的转换"><a href="#进程的转换" class="headerlink" title="进程的转换"></a>进程的转换</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713117219-4cb0e199-d621-45f5-8cf6-30126b9df746.png#height=492&amp;width=1030" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713117663-4167cc6e-e338-48ff-b4e0-1d400fa1e0be.png#height=602&amp;width=1112" srcset="/img/loading.gif" alt=""> </p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制：实现进程状态的转换<br>进程控制通过原语实现，原语用关/开中断来实现。原语是一种特殊的程序，原语的执行必须一气呵成，不能中断（使用开中断、关中断指令实现）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713118087-a80ae416-5094-4f2b-b9cb-adf5cecf518f.png#height=582&amp;width=1106" srcset="/img/loading.gif" alt=""> </p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ol><li>进程通信：进程之间的信息交换</li><li><p>共享存储</p><ul><li>内存分配一个共享空间，两个进程通过共享空间交流。</li><li>对于共享空间的访问必须是互斥的，不能同时写</li><li>基于数据结构的共享：低级通信方式，速度慢，限制多</li><li>基于存储区的共享：划分存储区，进程交流的方式由进程决定</li></ul></li><li><p>消息传递</p><ul><li>以格式化消息来传递</li><li>消息头、消息体组成（如计算机网络的报文）<ul><li>直接通信方式：消息直接挂到消息缓冲队列的队尾</li><li>间接通信方式：消息先发送到中间实体（信箱），如电子邮件系统（邮件服务器）</li></ul></li></ul></li><li>管道通信</li></ol><ul><li>管道：内存中固定大小的缓冲区</li><li>管道只能实现半双工通信，某个时间只能单向传输。如果同时双向通信，需要设置两个管道</li><li>各个进程要互斥地访问管道</li><li>数据以字符流写入管道，管道写满，write()就阻塞，管道读空，read()就阻塞</li><li>如果没写满，就不允许读。如果没读空，就不允许写</li><li>数据一旦读出，就会被从管道中抛弃，则读管道的进程只能有一个<br>  <img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713118545-0a000ee7-d174-46f3-9c9c-710f44a23fa2.png#height=722&amp;width=1100" srcset="/img/loading.gif" alt=""> </li></ul><h2 id="线程、多线程模型"><a href="#线程、多线程模型" class="headerlink" title="线程、多线程模型"></a>线程、多线程模型</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流</strong>的最小单位。线程提升了系统的并发度，使得进程内也能并发处理各种任务。<br>引入线程后，进程是<strong>资源分配</strong>的基本单位，<strong>线程是调度的基本单位</strong>。<br>引入线程后，各线程间也能并发，提升<strong>并发度</strong>。<br>引入线程后，并发带来的<strong>系统开销减少</strong>。主要是进程并发需要陷入内核态，线程就不需要</p><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><p>线程是CPU调度的单位<br>多CPU计算机中，各个线程可占用不同的CPU<br>每个线程都有一个线程ID、线程控制块（TCB）<br>线程也有 <strong>就绪、阻塞、运行</strong> 三种基本状态<br>线程几乎不拥有系统资源<br>同一进程的不同线程之间共享进程的资源<br>由于共享内存地址空间，线程间通信不需要系统干预</p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>线程在用户态，操作系统内核看不到</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>线程运行在内核态，操作系统内核可以看得见</p><h4 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h4><p>n个用户级线程映射到m个内核级线程上</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>多个用户级线程映射到一个内核级线程，每个用户进程对应一个内核级线程</p><ul><li>优点：用户级线程的切换在用户空间完成，线程管理开销小，效率高</li><li>缺点：用户级线程被阻塞，整个进程都会被阻塞，并发度不高，多个线程不能再多核机器并行运行<h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4>一个用户级线程映射到一个内核级线程，每个用户进程有与用户线程同等数量的内核级线程</li><li>优点：一个线程被阻塞，别的线程还能执行，并发能力强。</li><li>缺点：一个进程占用多个内核级线程，线程管理成本高，开销大<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4>n用户级线程映射到m个内核级线程（n&gt;=m），每个用户进程对应m个内核级线程<br>同时克服了一对一模型的缺点和多对一模型的缺点。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713118834-def00419-dbb8-4d29-9c9c-6f39cf1f6036.png#height=330&amp;width=1118" srcset="/img/loading.gif" alt=""> </p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713119334-4b530ff5-301c-4677-bfd1-053a3a5fca52.png#height=756&amp;width=1170" srcset="/img/loading.gif" alt=""> </p><h2 id="Modeling-Multiprogramming-多道程序设计模型"><a href="#Modeling-Multiprogramming-多道程序设计模型" class="headerlink" title="Modeling Multiprogramming  多道程序设计模型"></a>Modeling Multiprogramming  多道程序设计模型</h2><p>采用多道程序提高CPU利用率<br>$CPU utilization = 1 - p^{n}$ （p是进程等待IO的时间与其在内存中的时间比）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713119662-c8516ec0-fb9d-44e1-b283-c2454acb1b39.png#height=396&amp;width=662" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1580713119887-6fc997e7-7513-4275-90c6-a2f0d97fc290.png#height=358&amp;width=476" srcset="/img/loading.gif" alt=""><br>例子：对于一个512M内存的计算机，操作系统占128M，80%时间I/O，则CPU 利用率为=1-0.83=49%</p><h3 id="线程信号控制"><a href="#线程信号控制" class="headerlink" title="线程信号控制"></a>线程信号控制</h3><p>Signal 被用来在UNIX系统中唤醒进程，当有事件发生时<br>Signal</p><ul><li>Signal is generated by particular event</li><li>Signal is delivered to a process</li><li>Signal is handled</li></ul><p>方式：</p><ul><li>将信号传送给信号量应用的线程</li><li>将信号传递给进程的每个线程</li><li>将信号传递给进程中特定线程</li><li>指定一个特定线程来接受进程的所有信号</li></ul><h2 id="进程模型到线程模型的迁移"><a href="#进程模型到线程模型的迁移" class="headerlink" title="进程模型到线程模型的迁移"></a>进程模型到线程模型的迁移</h2><p>许多已有的程序是为单线程编写的，把这些程序改写为多线程会产生许多问题</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>对线程来说的<strong>全局变量</strong>对整个程序来说并不是全局的 </li><li>许多<strong>库过程</strong>是不可重入的</li><li>有些信号逻辑上是<strong>线程专用</strong>的，而有些不是</li><li>堆栈的管理</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>UNIX维护的errno全局变量，对线程来说是全局的变量，若两个线程先后访问，第二次会修改第一次的结果</li><li>UNIX的malloc()函数，在进行内存分配时，内存指针可能会指向不确定的位置，如果发生线程切换，会导致指针异常从而引起崩溃 </li><li>例如某个线程调用信号alarm，如果线程完全由用户实现，内核根本不知道有线程的存在，很难将信号发送给正确的线程 </li><li>如果一个堆栈溢出时，内核只需要为该进程提供更多的堆栈。当一个进程有多个线程时，就必须有多个堆栈。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><strong>禁用全局变量</strong>或者是为每个线程建立一份单独的<strong>全局变量拷贝区</strong></li><li>为每个过程提供一个<strong>包装器</strong>，该包装器设置一个二进制位来标志<strong>某个库正在使用中</strong>，在先前的调用为返回前，任何调用该库的线程都会被阻塞。（该方法会降低程序的并行性）</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Chapter 1 Introduction</title>
    <link href="/2020/01/16/OS-Chapter-1-Introduction/"/>
    <url>/2020/01/16/OS-Chapter-1-Introduction/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>控制和管理整个计算机系统的<strong>硬件和软件资源</strong>，并合理组织调度计算机的<strong>工作和资源的分配</strong>，以提供给用户和其他软件方便的接口和环境，它是计算机系统中<strong>最基本的系统软件</strong>。</p><ol><li>负责管理协调硬件、软件等计算机资源的工作</li><li>为上层的应用程序、用户提供简单易用的服务</li><li>操作系统是<strong>系统软件</strong>，而不是硬件</li></ol><h2 id="Basic-Concepts-of-OS"><a href="#Basic-Concepts-of-OS" class="headerlink" title="Basic Concepts of OS"></a>Basic Concepts of OS</h2><p>Processes：进程管理，进程树<br>Address spaces：地址空间，物理内存、虚拟内存<br>Files：文件系统，文件和目录<br>Input/Output：输入输出，I/O<br>Protection：硬件和软件<br>The shell：命令提示符<br>System Call：系统调用</p><ul><li>用户程序和系统程序之间的接口</li><li>在内核模式执行</li><li>POSIX API/ Windows Win32 API</li><li>系统调用类型<ul><li>进程控制：创建、终结进程，获取/设置 进程参数</li><li>文件操作：Create；delete；read；write；get/set file attributes</li><li>设备管理：Request；Release；Read；Write</li><li>Socket：Connection：Open/Accept/Read/Write/Close</li><li>信息维护：获取当前的日期，OS Version等</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173405333-9f452da9-ab11-47a5-a520-09ed9eedd5d6.png#align=left&amp;display=inline&amp;height=342&amp;name=image.png&amp;originHeight=342&amp;originWidth=641&amp;size=74291&amp;status=done&amp;style=none&amp;width=641" srcset="/img/loading.gif" alt="image.png"></p><h2 id="Characters-of-OS-操作系统的特征"><a href="#Characters-of-OS-操作系统的特征" class="headerlink" title="Characters of OS 操作系统的特征"></a>Characters of OS 操作系统的特征</h2><h3 id="Concurrency：并发"><a href="#Concurrency：并发" class="headerlink" title="Concurrency：并发"></a><strong>Concurrency：并发</strong></h3><p>并发 Concurrency：逻辑并发（宏观上看是同时执行的，微观上，是划分为小的时间片，一段时间A用，一段时间B用）<br>并行 Parallel：物理并发（A、B两个程序真的在同时执行</p><h3 id="Share：共享"><a href="#Share：共享" class="headerlink" title="Share：共享"></a><strong>Share：共享</strong></h3><p>CPU，Main Memory，Storage，I/O devices<br>Space，Time<br>互斥共享方式：一个时间段只允许一个进程访问该资源<br>同时共享方式：允许一个时间段由多个进程“同时”对它们进行访问</p><h3 id="Virtualization：虚拟"><a href="#Virtualization：虚拟" class="headerlink" title="Virtualization：虚拟"></a><strong>Virtualization：虚拟</strong></h3><p>虚拟式把物理上的实体变为若干个逻辑上的对应物。物理上实体是物理存在的，而逻辑上对应物是用户感受到的。<br>空分复用技术：虚拟内存，虚拟存储器技术<br>时分复用技术：单核CPU多线程，虚拟处理器<br>没有并发性，就谈不上虚拟性</p><h3 id="Asynchronism：异步"><a href="#Asynchronism：异步" class="headerlink" title="Asynchronism：异步"></a><strong>Asynchronism：异步</strong></h3><p>多道程序环境下，资源有限，程序以不可预知的速度向前推进，就是进程的异步性。<br><strong>只有系统拥有并发性，才有可能导致异步性。</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173184991-de572ab8-06fe-4e7b-95ee-e40b454954eb.png#align=left&amp;display=inline&amp;height=346&amp;originHeight=346&amp;originWidth=904&amp;status=done&amp;style=none&amp;width=904" srcset="/img/loading.gif" alt="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173184991-de572ab8-06fe-4e7b-95ee-e40b454954eb.png#align=left&amp;display=inline&amp;height=346&amp;originHeight=346&amp;originWidth=904&amp;status=done&amp;style=none&amp;width=904"><br><strong>知识点：</strong><br>并发与并行的区别<br>并发与共享互为存在条件<br>没有并发和共享，就谈不上虚拟和异步，因此<strong>并发</strong>和<strong>共享</strong>是操作系统的两个<strong>最基本的特征</strong></p><h2 id="OS-Runtime-Structure-运行机制体系结构"><a href="#OS-Runtime-Structure-运行机制体系结构" class="headerlink" title="OS Runtime Structure 运行机制体系结构"></a>OS Runtime Structure 运行机制体系结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>两种指令：</p><ul><li>特权指令：如I/O指令、内存清零指令</li><li>非特权指令：如运算指令</li></ul><p>两种处理器状态：程序状态字寄存器（PSW）</p><ul><li>用户态：CPU只能执行非特权指令</li><li>核心态：特权指令、非特权指令都可以执行</li></ul><p>两种程序：</p><ul><li>内核程序：系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li><li>应用程序：普通应用程序只能执行非特权指令，运行在用户态。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173185433-db7ed8c8-96bc-4195-8094-47fa55f4aa4d.png#align=left&amp;display=inline&amp;height=412&amp;originHeight=412&amp;originWidth=988&amp;status=done&amp;style=none&amp;width=988" srcset="/img/loading.gif" alt=""><br>单体系统：全部操作系统在内核态中以单一程序的方式运行<br>主程序：处理服务过程请求<br>服务过程：执行系统调用<br>使用过程：辅助服务过程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173185860-a6e659c6-5dc8-4746-98d7-e6d306e4dc19.png#align=left&amp;display=inline&amp;height=414&amp;originHeight=414&amp;originWidth=932&amp;status=done&amp;style=none&amp;width=932" srcset="/img/loading.gif" alt=""><br>层次式系统：上层软件都是在下一层软件的基础上构建的。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173186193-f5a7dbe9-1bb0-42d7-83d8-71b51ab939c8.png#align=left&amp;display=inline&amp;height=342&amp;originHeight=342&amp;originWidth=744&amp;status=done&amp;style=none&amp;width=744" srcset="/img/loading.gif" alt=""><br>微内核：<br>仅有一个模块（微内核）运行在内核态，剩下全都在用户态。MINIX 3 微内核<br>只有时钟管理、中断处理、原语等，不包括进程管理、存储器管理、设备管理等功能。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173186536-92fd38d9-dd41-4c81-83be-8cd9665cbd2e.png#align=left&amp;display=inline&amp;height=384&amp;originHeight=384&amp;originWidth=756&amp;status=done&amp;style=none&amp;width=756" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173186920-c0cd99a3-42a8-4636-a3e4-98051b729e0c.png#align=left&amp;display=inline&amp;height=410&amp;originHeight=410&amp;originWidth=752&amp;status=done&amp;style=none&amp;width=752" srcset="/img/loading.gif" alt=""><br>Client-Server模式（Web运行模式）<br>服务器：提供服务<br>客户端：使用服务<br>服务器与客户端之间通过消息传递方式<br>虚拟机：</p><ol><li>VM370</li><li>多道程序</li><li>一个比裸机更方便、有扩展界面的计算机。裸机硬件的精确复刻品<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173187230-8cfa07ac-ed11-459f-9019-4eae69dd5edd.png#align=left&amp;display=inline&amp;height=294&amp;originHeight=294&amp;originWidth=678&amp;status=done&amp;style=none&amp;width=678" srcset="/img/loading.gif" alt=""> </li><li>hypervisor Ⅰ<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173187677-f8abcd41-bdfe-42c3-b3d5-c92cda38a8cb.png#align=left&amp;display=inline&amp;height=476&amp;originHeight=476&amp;originWidth=906&amp;status=done&amp;style=none&amp;width=906" srcset="/img/loading.gif" alt=""> </li></ol><p>外核（exokernel）：<br>通过<strong>拆分硬件资源</strong>来分配给虚拟机，比如一块硬盘，某个虚拟机获得磁盘的0-1023盘块，而另一台虚拟机获得1024-2047盘块。<br>这样做减少了映射层，这样就少了一张表格来维护重映像磁盘地址。</p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h3><p>发生中断意味着需要操作系统介入，开展管理工作</p><h3 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a>中断的概念和作用</h3><ol><li>中断发生时，CPU会立即进入<strong>核心态</strong></li><li>中断发生后，当前运行进程暂停运行，并由操作系统内核对中断进行处理</li><li>中断信号不同，处理方式不同</li></ol><p>有了中断，才能实现<strong>多道程序并发执行</strong>。<br>中断可以使CPU从用户态切换为核心态，被操作系统获得计算机的控制权。</p><div class="table-container"><table><thead><tr><th>用户态→核心态</th><th>中断</th></tr></thead><tbody><tr><td>核心态→用户态</td><td>改变程序状态字</td></tr></tbody></table></div><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p>内中断（也称异常、例外、陷入（陷阱））：<strong>信号来源</strong>：CPU内部，与当前执行的指令相关。<br>自愿中断——指令中断<br>强迫中断<br><strong>硬件故障</strong>：如缺页<br>软件中断：如软件出现异常Exception<br>外中断（中断——狭义的中断）：<strong>信号来源</strong>：CPU外部，与当前执行的指令无关<br>外设请求：如IO完成操作<br>人工干预：用户强制停止进程</p><p>外中断处理过程：</p><ol><li>每条指令执行完后检查是否有中断请求</li><li>如果检测到中断请求，保护被中断程序的CPU环境（保护现场）（如程序状态字、程序计数器、寄存器）</li><li>根据中断信号处理中断程序</li><li>恢复原程序的CPU环境（<strong>恢复现场</strong>）并退出中断，返回原程序继续执行<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173188337-f5e314fd-5026-46a1-874b-122c7eacbf4e.png#align=left&amp;display=inline&amp;height=666&amp;originHeight=666&amp;originWidth=1062&amp;status=done&amp;style=none&amp;width=1062" srcset="/img/loading.gif" alt=""> </li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173188637-a41e4130-c9fd-424b-bd48-e3f18820a904.png#align=left&amp;display=inline&amp;height=238&amp;originHeight=238&amp;originWidth=360&amp;status=done&amp;style=none&amp;width=360" srcset="/img/loading.gif" alt=""><br><strong>程序接口</strong>就是由一组系统调用来组成的</p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。需要<strong>访问系统资源</strong>，都需要系统代为完成，所以需要系统调用，这样可以保证系统的稳定性和安全性，防止用户的非法操作。<br><strong>系统调用会让CPU从用户态进入核心态</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173188990-8137f146-6154-4d50-a2a4-52327858beb6.png#align=left&amp;display=inline&amp;height=284&amp;originHeight=284&amp;originWidth=1008&amp;status=done&amp;style=none&amp;width=1008" srcset="/img/loading.gif" alt=""> </p><h3 id="系统调用-amp-库函数"><a href="#系统调用-amp-库函数" class="headerlink" title="系统调用 &amp; 库函数"></a>系统调用 &amp; 库函数</h3><p>系统调用是操作系统向上层提供的接口<br>有些库函数是对系统调用的进一步封装<br>当今应用程序大多通过高级语言直接or间接进行系统调用</p><h3 id="系统调用背后过程"><a href="#系统调用背后过程" class="headerlink" title="系统调用背后过程"></a>系统调用背后过程</h3><ol><li>传递系统调用参数</li><li>执行<strong>陷入</strong>（trap、int）指令</li><li>执行系统调用相应服务程序</li><li>返回用户程序<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579173189616-6145f499-f5f5-4dd6-a76d-c3c730acae44.png#align=left&amp;display=inline&amp;height=680&amp;originHeight=680&amp;originWidth=1038&amp;status=done&amp;style=none&amp;width=1038" srcset="/img/loading.gif" alt=""> </li></ol><h2 id="操作系统的管理功能"><a href="#操作系统的管理功能" class="headerlink" title="操作系统的管理功能"></a>操作系统的管理功能</h2><ul><li>进程管理</li><li>存储管理</li><li>设备管理</li><li>文件管理</li><li>作业管理</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAT32 File System</title>
    <link href="/2020/01/16/FAT32_File_System/"/>
    <url>/2020/01/16/FAT32_File_System/</url>
    
    <content type="html"><![CDATA[<p>早期的文件系统是以FAT(File Allocate Table)文件分配表形式组织形成的，由于操作系统作业需要实现一个<strong>FAT32</strong>文件系统，所以这里简单介绍了解一下FAT文件系统的组织结构及具体实现。</p><a id="more"></a><h2 id="Pre-knowledge"><a href="#Pre-knowledge" class="headerlink" title="Pre-knowledge"></a>Pre-knowledge</h2><h3 id="MBR（Main-Boot-Record）"><a href="#MBR（Main-Boot-Record）" class="headerlink" title="MBR（Main Boot Record）"></a>MBR（Main Boot Record）</h3><p><strong>主引导</strong>记录，占446字节, 为计算机启动后从可启动介质上首先装入内存并且执行的代码，通常用来解释分区结构。</p><h3 id="DBR（DOS-Boot-Record）"><a href="#DBR（DOS-Boot-Record）" class="headerlink" title="DBR（DOS Boot Record）"></a>DBR（DOS Boot Record）</h3><p>DOS引导记录，为操作系统进入<strong>文件系统</strong>以后可以访问的第一个扇区，通常用来解释文件系统，DBR是由硬盘的MBR装载的程序段。DBR装入内存后，即开始执行该引导程序段，其主要功能是<strong>完成操作系统的自举并将控制权交给操作系统</strong>。每个分区都有引导扇区，但只有被设为活动分区才会被MBR装的DBR入内存运行。</p><h3 id="EBR（Extended-Boot-Record）"><a href="#EBR（Extended-Boot-Record）" class="headerlink" title="EBR（Extended Boot Record）"></a>EBR（Extended Boot Record）</h3><p>扩展分区引导记录，类似于主引导记录MBR.因为MBR四条分区信息的限制,可以使用EBR方便扩展.它的结构与MBR类似,但是没有引导程序和磁盘签名,仅仅保留了分区表和结束标志。</p><h1 id="FAT32-File-System"><a href="#FAT32-File-System" class="headerlink" title="FAT32 File System"></a>FAT32 File System</h1><h2 id="Introduction-to-FAT32"><a href="#Introduction-to-FAT32" class="headerlink" title="Introduction to FAT32"></a>Introduction to FAT32</h2><ul><li>FAT（File Allocation Table，文件分配表）文件系统是windows操作系统所使用的一种文件系统，它的发展过程经历了FAT12、FAT16、FAT32三个阶段。FAT文件系统用“簇”作为数据单元。一个“簇”由一组连续的扇区组成，簇所含的扇区数必须是2的整数次幂。簇的最大值为64个扇区，即32KB（一个扇区512Bytes）。所有簇从2开始进行编号，每个簇都有一个自己的地址编号。用户文件和目录都存储在簇中。</li><li>FAT文件系统的数据结构中有两个重要的结构：<strong>文件分配表</strong>和<strong>目录项</strong>：<ul><li>文件分配表：文件和文件夹内容储存在簇中，如果一个文件或文件夹需要多于一个簇的空间，则用FAT表来描述，如何找到另外的簇。FAT结构用于指出文件的下一个簇，同时也说明了簇的分配状态。FAT12、FAT16、FAT32这三种文件系统之间的主要区别在于<strong>FAT项的大小不同</strong>。</li><li>目录项：FAT文件系统的每一个文件和文件夹都被分配到一个目录项，目录项中记录着<strong>文件名、大小、文件内容</strong>起始地址以及其他一些元数据。</li></ul></li><li>在FAT文件系统中，文件系统的数据记录在“<strong>引导扇区中（DBR）</strong>”中。引导扇区位于整个文件系统的<strong>0号扇区</strong>，是文件系统隐藏区域（也称为保留区）的一部分，我们称其为<strong>DBR扇区</strong>，DBR中记录着文件系统的<strong>起始位置、大小、FAT表个数及大小等</strong>相关信息。在FAT文件系统中，同时使用“<strong>扇区地址</strong>”和“<strong>簇地址</strong>”两种地址管理方式。这是因为只有存储用户数据的数据区使用簇进行管理（FAT12和FAT16的根目录除外），所有簇都位于数据区。其他文件系统管理数据区域是不以簇进行管理的，这部分区域使用<strong>扇区地址</strong>进行管理。文件系统的起始扇区为0号扇区(逻辑0扇区)。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579171001263-6a9761c1-9f50-4cda-b5eb-dc79ad6ebd4c.png#align=left&amp;display=inline&amp;height=462&amp;originHeight=462&amp;originWidth=1476&amp;status=done&amp;style=none&amp;width=1476" srcset="/img/loading.gif" alt=""><h2 id="FAT32-file-structure"><a href="#FAT32-file-structure" class="headerlink" title="FAT32 file structure"></a>FAT32 file structure</h2></li><li>保留区：DOS引导扇区，FAT12、FAT16一般只有一个引导扇区，FAT32多一些。</li><li>FAT表：FAT区由两个大小相等的FAT文件分配表组成，FAT1、FAT2挨着</li><li>数据区：FAT32根目录通常位于2号簇。FAT12、FAT16的根目录虽然也属于数据区，但是他们并不由簇进行管理。也就是说FAT12、FAT16的根目录是没有簇号的，他们的2号簇从根目录之后开始。<h2 id="Reserved-Partition"><a href="#Reserved-Partition" class="headerlink" title="Reserved Partition"></a>Reserved Partition</h2>保留区由若干个扇区组成，保留区大小记录在DBR扇区中，常见为32、34、38个扇区。由DBR中0x0e和0x0f两个地址的数值决定，小端字节序，即N的值。<h2 id="DBR"><a href="#DBR" class="headerlink" title="DBR"></a>DBR</h2><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579171001724-dfafaab0-7b12-4343-b29f-2918ccb37002.png#align=left&amp;display=inline&amp;height=649&amp;originHeight=842&amp;originWidth=956&amp;status=done&amp;style=none&amp;width=737" srcset="/img/loading.gif" alt=""> </li><li>0x00~0x02：3字节，跳转指令。</li><li>0x03~0x0A：8字节，文件系统标志和版本号，这里为MSDOS5.0。</li><li>0x0B~0x0C：2字节，<strong>每扇区字节数</strong>，0x0200=512</li><li>0x0D~0x0D：1字节，<strong>每簇扇区数</strong>，0x08</li><li>0x0E~0x0F：2字节，<strong>保留扇区数</strong>，0x0C22=3106</li><li>0x10~0x10：1字节，<strong>FAT表个数</strong>，0x02</li><li>0x11~0x12：2字节，FAT32必须等于0，FAT12/FAT16为根目录中目录的个数</li><li>0x13~0x14：2字节，FAT32必须等于0，FAT12/FAT16为扇区总数。</li><li>0x15~0x15：1字节，哪种存储介质，0xF8标准值，可移动存储介质。</li><li>0x16~0x17：2字节，FAT32必须为0，FAT12/FAT16为一个FAT 表所占的扇区数。</li><li>0x18~0x19：2字节，每磁道扇区数，只对于“特殊形状”（由磁头和柱面分割为若干磁道）的存储介质有效，0x003F=63。</li><li>0x1A~0x1B：2字节，磁头数，只对特殊的介质才有效，0x00FF=255。</li><li>0x1C~0x1F：4字节，EBR分区之前所隐藏的扇区数，0x0004A800=305152又出现了呢，与MBR中地址0x1C6开始的4个字节数值相等。</li><li>0x20~0x23：4字节，<strong>文件系统总扇区数</strong>，0x00E83800=15218688</li><li>0x24~0x27：4字节，<strong>每个FAT表占用扇区数</strong>，0x000039EF=14831</li><li>0x28~0x29：2字节，标记，此域FAT32 特有。</li><li>0x2A~0x2B：2字节，FAT32版本号0.0，FAT32特有。</li><li>0x2C~0x2F：4字节，<strong>根目录所在第一个簇的簇</strong>号，0x02。（虽然在FAT32文件系统下，根目录可以存放在数据区的任何位置，但是通常情况下还是起始于2号簇）</li><li>0x30~0x31：2字节，FSINFO（文件系统信息扇区）扇区号0x01，该扇区为操作系统提供关于空簇总数及下一可用簇的信息。</li><li>0x32~0x33：2字节，备份引导扇区的位置。备份引导扇区总是位于文件系统的6号扇区。</li><li>0x34~0x3F：12字节，用于以后FAT 扩展使用。</li><li>0x40~0x40：1字节，与FAT12/16 的定义相同，只不过两者位于启动扇区不同的位置而已。</li><li>0x41~0x41：1字节，与FAT12/16 的定义相同，只不过两者位于启动扇区不同的位置而已 。</li><li>0x42~0x42：1字节，扩展引导标志，0x29。与FAT12/16 的定义相同，只不过两者位于启动扇区不同的位置而已</li><li>0x43~0x46：4字节，卷序列号。通常为一个随机值。</li><li>0x47~0x51：11字节，卷标（ASCII码），如果建立文件系统的时候指定了卷标，会保存在此。</li><li>0x52~0x59：8字节，文件系统格式的ASCII码，FAT32。</li><li>0x5A~0x1FD：共410字节，引导代码。</li><li>0x1FE~0x1FF：签名标志“55 AA”。<br>FAT文件系统将引导代码与文件形同数据结构融合在FAT32文件系统引导扇区的512字节中，90~509字节为引导代码，而FAT12/16则是62~509字节为引导代码。同时，FAT32还可以利用引导扇区后的扇区空间存放附加的引导代码。一个FAT卷即使不是可引导文件系统，也会存在引导代码。<h2 id="FSINFO扇区"><a href="#FSINFO扇区" class="headerlink" title="FSINFO扇区"></a>FSINFO扇区</h2>FAT32在保留区中增加了一个FSINFO扇区，用以记录文件系统中空闲簇的数量以及下一可用簇的簇号等信息，以供操作系统作为参考。FSINFO信息扇区一般位于文件系统的1号扇区，结构非常简单。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/431085/1579171002162-e0a9a671-57ee-4325-bc97-d692c0f7230e.png#align=left&amp;display=inline&amp;height=598&amp;originHeight=840&amp;originWidth=954&amp;status=done&amp;style=none&amp;width=679" srcset="/img/loading.gif" alt=""> </li><li>0x200~0x203：4个字节，扩展引导标志“0x52526141”。</li><li>0x204~0x3E3：480个字节，未使用，全部置0。</li><li>0x3E4~0x3E7：4个字节，FSINFO签名“0x72724161”。</li><li>0x3E8~0x3EB：4个字节，文件系统的空簇数，0xFFFFFFFF,这个值感觉有问题，格式化SD卡新建一个小于4K的文件，此处的值变成0x1CF6FE，所以上面的值应该为0x1FF6FF，猜测可能是由于格式化之后就会将此处置FF，新建文件后才会恢复</li><li>0x3EC~0x3EF：4个字节，下一可用簇号（0x00000002）。</li><li>0x3F0~0x3FD：14个字节，未使用。</li><li>0x3FE~0x3FF：2个字节，“55 AA”标志。</li><li>温馨提示：通常情况下，文件系统的2号扇区结尾也会被设置“55 AA”标志。6号扇区也会有一个引导扇区的备份，相应的7号扇区应该是一个备份FSINFO信息扇区，8号扇区可以看做是2号扇区的备份。</li></ul><h2 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h2><p>保留分区后面的是FAT区，由两个完全相同的FAT（File Allocation Table，分区表）构成。FAT表是一组与数据簇号对应的列表。FAT2紧跟在FAT1之后，可以由 FAT表扇区数+FAT1 计算出来。</p><h2 id="FAT表作用"><a href="#FAT表作用" class="headerlink" title="FAT表作用"></a>FAT表作用</h2><ul><li>文件系统分配磁盘空间按簇来分配。因此，文件占有磁盘空间时，基本单位不是字节而是<strong>簇</strong>，即使某个文件只有一个字节，操作系统也会给它分配一个<strong>最小单元</strong>：即一个<strong>簇</strong>。对于大文件，需要分配多个簇。同一个文件的数据并不一定完整地存放在磁盘中一个连续地区域内，而往往会分若干段，像链子一样存放。这种存储方式称为文件的链式存储。为了实现文件的链式存储，文件系统必须准确地记录哪些簇已经被文件占用，还必须为每个已经占用的簇指明存储后继的下一个簇的簇号，对于文件的最后一簇，则要指明本簇无后继簇。这些都是由FAT表来保存的，FAT 表对应表项中记录着它所代表的簇的有关信息：诸如是空，是不是坏簇，是否是已经是某个文件的尾簇等。</li><li>对于文件系统来说，FAT表有两个重要作用：<strong>描述簇的分配状态</strong>以及<strong>标明文件或目录的下一簇的簇号</strong>。</li><li>通常情况下，一个FAT文件系统会有两个FAT表，但有时也允许只有一个FAT表，FAT表的具体个数记录在引导扇区的偏移0x10字节处。</li><li>由于FAT区紧跟在文件系统保留区后，所以FAT1在文件系统中的位置可以通过引导记录中偏移0x0E~0x0F字节处的“<strong>保留扇区数</strong>”得到，即M值。<h2 id="FAT表分析"><a href="#FAT表分析" class="headerlink" title="FAT表分析"></a>FAT表分析</h2>FAT32中每个簇地址都有$32bit$，则FAT表中所有地址位置以4字节（Bytes）为单位进行划分，并且对划分后位置为0的地址进行编号，0号地址与1号地址系统保留，从2号地址开始，每个地址对应于数据区的簇号。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>File System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统简答题目</title>
    <link href="/2020/01/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E7%AD%94%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/01/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E7%AD%94%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>在操作系统中有好多细节的知识，同时这些知识需要多方面的对比。所以在这里简单整理几个操作系统考试中容易出现的简答题。<br><a id="more"></a></p><h4 id="1-分页与分段的区别"><a href="#1-分页与分段的区别" class="headerlink" title="1. 分页与分段的区别"></a>1. 分页与分段的区别</h4><ol><li>页是信息的<strong>物理单位</strong>，分页是为了系统管理内存的方便而进行的，故对用户而言，分页是不可见的，是透明的<br>段是信息的<strong>逻辑单位</strong>，分段是作业逻辑上的要求，对用户而言，分段是可见的。</li><li>页的大小是<strong>固定的</strong>，由系统决定；段的大小是<strong>不固定的</strong>，由用户作业本身决定。</li><li>从用户角度看，分页的地址空间是<strong>一维的（页号）</strong>，而段的地址空间是<strong>二维的（段名+偏移量）</strong>。</li></ol><h4 id="2-死锁产生的4个必要条件是什么？它们是彼此独立的吗？"><a href="#2-死锁产生的4个必要条件是什么？它们是彼此独立的吗？" class="headerlink" title="2. 死锁产生的4个必要条件是什么？它们是彼此独立的吗？"></a>2. 死锁产生的4个必要条件是什么？它们是彼此独立的吗？</h4><ul><li><strong>互斥</strong>，<strong>请求和保持</strong>，<strong>不剥夺</strong>，<strong>环路等待</strong>。</li><li>不是相互独立的，前三个条件是<strong>必要条件</strong>，而环路等待实际上是在前三者基础上的一种<strong>可能的结果</strong>，是死锁的一种现象。</li></ul><h4 id="3-当系统中的地址空间非常大时（例如32位），会给页表的设计带来什么问题？请给出一个方案并分析其优缺点"><a href="#3-当系统中的地址空间非常大时（例如32位），会给页表的设计带来什么问题？请给出一个方案并分析其优缺点" class="headerlink" title="3. 当系统中的地址空间非常大时（例如32位），会给页表的设计带来什么问题？请给出一个方案并分析其优缺点"></a>3. 当系统中的地址空间非常大时（例如32位），会给页表的设计带来什么问题？请给出一个方案并分析其优缺点</h4><ol><li>会导致<strong>页表过长</strong>从而很难找到一块<strong>连续的</strong>存储空间存放页表，此外如果页表中的行不连续也会加大访问页表的查找时间。 </li><li>可以用<strong>多级页表</strong>解决这个问题，将页表分页，离散地存储在不同区域，同时建立另一张页表映射原来页表的每一页。优点是不需要大块的<strong>连续空间</strong>，但并没有减少页表的空间，同时也增加了<strong>访存次数</strong>。</li></ol><h4 id="4-文件在磁盘上存放的形式有几种？它们与存取方法有何关系？"><a href="#4-文件在磁盘上存放的形式有几种？它们与存取方法有何关系？" class="headerlink" title="4. 文件在磁盘上存放的形式有几种？它们与存取方法有何关系？ "></a>4. 文件在磁盘上存放的形式有几种？它们与存取方法有何关系？ </h4><div class="table-container"><table><thead><tr><th style="text-align:center">顺序结构</th><th style="text-align:center">链式结构</th><th style="text-align:center">索引结构</th></tr></thead><tbody><tr><td style="text-align:center">顺序</td><td style="text-align:center">顺序</td><td style="text-align:center">顺序</td></tr><tr><td style="text-align:center">随机</td><td style="text-align:center"></td><td style="text-align:center">随机</td></tr></tbody></table></div><h4 id="5-请说明中断驱动I-O方式和DMA方式有什么不同？"><a href="#5-请说明中断驱动I-O方式和DMA方式有什么不同？" class="headerlink" title="5. 请说明中断驱动I/O方式和DMA方式有什么不同？"></a>5. 请说明中断驱动I/O方式和DMA方式有什么不同？</h4><ol><li><strong>中断频率</strong>。在中断方式中，每当输入数据缓冲寄存器中装满输入数据或将输出数据缓冲寄存器中的数据输出之后，设备控制器便发生<strong>一次中断</strong>。由于设备控制器中配置的数据缓冲寄存器通常较小，因此中断比较<strong>频繁</strong>；而<strong>DMA方式</strong>下，在DMA控制器的控制下，一次能完成一批连续数据的传输，并在整批数据传送完后才发生一次中断，因此可大大减少<strong>CPU处理I/O中断的时间</strong>。</li><li><strong>数据的传送方式</strong>。在<strong>中断方式</strong>下，由CPU直接将输入数据写入控制器的数据缓冲寄存器供设备输出，或在中断发生后直接从数据缓冲寄存器中取出输入数据供进程处理，即数据传送<strong>必须经过CPU</strong>；而在DMA方式中，数据的传输在DMA控制器的控制下直接在<strong>内存和I/O设备间</strong>进行，CPU只需将数据传输的<strong>磁盘地址</strong>、<strong>内存地址</strong>和<strong>字节数</strong>传给<strong>DMA控制器</strong>即可。</li></ol><h4 id="6-试述缺页中断与一般中断的主要区别。"><a href="#6-试述缺页中断与一般中断的主要区别。" class="headerlink" title="6. 试述缺页中断与一般中断的主要区别。"></a>6. 试述缺页中断与一般中断的主要区别。</h4><ol><li>在指令<strong>执行期间</strong>和处理<strong>中断信号</strong></li><li>一条指令执行期间可能产生<strong>多次缺页中断</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统(Operating System)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>Examination</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/05/hello-world/"/>
    <url>/2019/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
